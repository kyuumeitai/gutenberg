{"version":3,"sources":["/Users/ky/Sites/valet/copesacontent/web/app/plugins/gutenberg/packages/editor/src/store/effects.js"],"names":["compact","last","parse","getBlockType","switchToBlockType","doBlocksMatchTemplate","synchronizeBlocksWithTemplate","setupEditorState","replaceBlocks","selectBlock","resetBlocks","setTemplateValidity","insertDefaultBlock","getBlock","getBlockRootClientId","getBlocks","getBlockCount","getPreviousBlockClientId","getSelectedBlock","getTemplate","getTemplateLock","isValidTemplate","fetchReusableBlocks","saveReusableBlocks","deleteReusableBlocks","convertBlockToReusable","convertBlockToStatic","receiveReusableBlocks","requestPostUpdate","requestPostUpdateSuccess","requestPostUpdateFailure","trashPost","trashPostFailure","refreshPost","validateBlocksToTemplate","action","store","state","getState","template","templateLock","isBlocksValidToTemplate","blocks","selectPreviousBlock","selectPrevious","firstRemovedBlockClientId","clientIds","currentSelectedBlock","previousState","editor","present","past","rootClientId","blockClientIdToSelect","ensureDefaultBlock","REQUEST_POST_UPDATE","REQUEST_POST_UPDATE_SUCCESS","REQUEST_POST_UPDATE_FAILURE","TRASH_POST","TRASH_POST_FAILURE","REFRESH_POST","MERGE_BLOCKS","dispatch","firstBlockClientId","secondBlockClientId","blockA","blockB","blockType","name","merge","clientId","blocksWithTheSameType","length","updatedAttributes","attributes","slice","SETUP_EDITOR","post","content","raw","isNewPost","status","edits","title","setupAction","RESET_BLOCKS","SYNCHRONIZE_TEMPLATE","updatedBlockList","FETCH_REUSABLE_BLOCKS","SAVE_REUSABLE_BLOCK","DELETE_REUSABLE_BLOCK","RECEIVE_REUSABLE_BLOCKS","CONVERT_BLOCK_TO_STATIC","CONVERT_BLOCK_TO_REUSABLE","REMOVE_BLOCKS","REPLACE_BLOCKS"],"mappings":";;;;AAAA;;;AAGA,SAASA,OAAT,EAAkBC,IAAlB,QAA8B,QAA9B;AAEA;;;;AAGA,SACCC,KADD,EAECC,YAFD,EAGCC,iBAHD,EAICC,qBAJD,EAKCC,6BALD,QAMO,mBANP;AAQA;;;;AAGA,SACCC,gBADD,EAECC,aAFD,EAGCC,WAHD,EAICC,WAJD,EAKCC,mBALD,EAMCC,kBAND,QAOO,WAPP;AAQA,SACCC,QADD,EAECC,oBAFD,EAGCC,SAHD,EAICC,aAJD,EAKCC,wBALD,EAMCC,gBAND,EAOCC,WAPD,EAQCC,eARD,EASCC,eATD,QAUO,aAVP;AAWA,SACCC,mBADD,EAECC,kBAFD,EAGCC,oBAHD,EAICC,sBAJD,EAKCC,oBALD,EAMCC,qBAND,QAOO,2BAPP;AAQA,SACCC,iBADD,EAECC,wBAFD,EAGCC,wBAHD,EAICC,SAJD,EAKCC,gBALD,EAMCC,WAND,QAOO,iBAPP;AASA;;;;;;;;;;;;AAWA,OAAO,SAASC,wBAAT,CAAmCC,MAAnC,EAA2CC,KAA3C,EAAmD;AACzD,MAAMC,KAAK,GAAGD,KAAK,CAACE,QAAN,EAAd;AACA,MAAMC,QAAQ,GAAGpB,WAAW,CAAEkB,KAAF,CAA5B;AACA,MAAMG,YAAY,GAAGpB,eAAe,CAAEiB,KAAF,CAApC,CAHyD,CAKzD;AACA;;AACA,MAAMI,uBAAuB,GAC5B,CAAEF,QAAF,IACAC,YAAY,KAAK,KADjB,IAEAnC,qBAAqB,CAAE8B,MAAM,CAACO,MAAT,EAAiBH,QAAjB,CAHtB,CAPyD,CAazD;;AACA,MAAKE,uBAAuB,KAAKpB,eAAe,CAAEgB,KAAF,CAAhD,EAA4D;AAC3D,WAAO1B,mBAAmB,CAAE8B,uBAAF,CAA1B;AACA;AACD;AAED;;;;;;;;;;;AAUA,OAAO,SAASE,mBAAT,CAA8BR,MAA9B,EAAsCC,KAAtC,EAA8C;AACpD;AACA,MAAK,CAAED,MAAM,CAACS,cAAd,EAA+B;AAC9B;AACA;;AAED,MAAMC,yBAAyB,GAAGV,MAAM,CAACW,SAAP,CAAkB,CAAlB,CAAlC;AACA,MAAMT,KAAK,GAAGD,KAAK,CAACE,QAAN,EAAd;AACA,MAAMS,oBAAoB,GAAG7B,gBAAgB,CAAEmB,KAAF,CAA7C,CARoD,CAUpD;;AACA,MAAMW,aAAa,qBAAQX,KAAR;AAAeY,IAAAA,MAAM,EAAE;AAAEC,MAAAA,OAAO,EAAEjD,IAAI,CAAEoC,KAAK,CAACY,MAAN,CAAaE,IAAf;AAAf;AAAvB,IAAnB,CAXoD,CAapD;;;AACA,MAAMC,YAAY,GAAGtC,oBAAoB,CAAEkC,aAAF,EAAiBH,yBAAjB,CAAzC,CAdoD,CAgBpD;AACA;;AACA,MAAMQ,qBAAqB,GAAGpC,wBAAwB,CAAE+B,aAAF,EAAiBH,yBAAjB,CAAxB,IAAwEO,YAAtG,CAlBoD,CAoBpD;AACA;;AACA,MAAKC,qBAAqB,KAAKN,oBAA/B,EAAsD;AACrD,WAAOtC,WAAW,CAAE4C,qBAAF,EAAyB,CAAC,CAA1B,CAAlB;AACA;AACD;AAED;;;;;;;;;;;;AAWA,OAAO,SAASC,kBAAT,CAA6BnB,MAA7B,EAAqCC,KAArC,EAA6C;AACnD,MAAK,CAAEpB,aAAa,CAAEoB,KAAK,CAACE,QAAN,EAAF,CAApB,EAA2C;AAC1C,WAAO1B,kBAAkB,EAAzB;AACA;AACD;AAED,eAAe;AACd2C,EAAAA,mBAAmB,EAAE,6BAAEpB,MAAF,EAAUC,KAAV,EAAqB;AACzCR,IAAAA,iBAAiB,CAAEO,MAAF,EAAUC,KAAV,CAAjB;AACA,GAHa;AAIdoB,EAAAA,2BAA2B,EAAE3B,wBAJf;AAKd4B,EAAAA,2BAA2B,EAAE3B,wBALf;AAMd4B,EAAAA,UAAU,EAAE,oBAAEvB,MAAF,EAAUC,KAAV,EAAqB;AAChCL,IAAAA,SAAS,CAAEI,MAAF,EAAUC,KAAV,CAAT;AACA,GARa;AASduB,EAAAA,kBAAkB,EAAE3B,gBATN;AAUd4B,EAAAA,YAAY,EAAE,sBAAEzB,MAAF,EAAUC,KAAV,EAAqB;AAClCH,IAAAA,WAAW,CAAEE,MAAF,EAAUC,KAAV,CAAX;AACA,GAZa;AAadyB,EAAAA,YAbc,wBAaA1B,MAbA,EAaQC,KAbR,EAagB;AAAA,QACrB0B,QADqB,GACR1B,KADQ,CACrB0B,QADqB;AAE7B,QAAMzB,KAAK,GAAGD,KAAK,CAACE,QAAN,EAAd;;AAF6B,wCAGuBH,MAAM,CAACO,MAH9B;AAAA,QAGrBqB,kBAHqB;AAAA,QAGDC,mBAHC;;AAI7B,QAAMC,MAAM,GAAGpD,QAAQ,CAAEwB,KAAF,EAAS0B,kBAAT,CAAvB;AACA,QAAMG,MAAM,GAAGrD,QAAQ,CAAEwB,KAAF,EAAS2B,mBAAT,CAAvB;AACA,QAAMG,SAAS,GAAGhE,YAAY,CAAE8D,MAAM,CAACG,IAAT,CAA9B,CAN6B,CAQ7B;;AACA,QAAK,CAAED,SAAS,CAACE,KAAjB,EAAyB;AACxBP,MAAAA,QAAQ,CAAErD,WAAW,CAAEwD,MAAM,CAACK,QAAT,CAAb,CAAR;AACA;AACA,KAZ4B,CAc7B;AACA;;;AACA,QAAMC,qBAAqB,GAAGN,MAAM,CAACG,IAAP,KAAgBF,MAAM,CAACE,IAAvB,GAC7B,CAAEF,MAAF,CAD6B,GAE7B9D,iBAAiB,CAAE8D,MAAF,EAAUD,MAAM,CAACG,IAAjB,CAFlB,CAhB6B,CAoB7B;;AACA,QAAK,CAAEG,qBAAF,IAA2B,CAAEA,qBAAqB,CAACC,MAAxD,EAAiE;AAChE;AACA,KAvB4B,CAyB7B;;;AACA,QAAMC,iBAAiB,GAAGN,SAAS,CAACE,KAAV,CACzBJ,MAAM,CAACS,UADkB,EAEzBH,qBAAqB,CAAE,CAAF,CAArB,CAA2BG,UAFF,CAA1B;AAKAZ,IAAAA,QAAQ,CAAErD,WAAW,CAAEwD,MAAM,CAACK,QAAT,EAAmB,CAAC,CAApB,CAAb,CAAR;AACAR,IAAAA,QAAQ,CAAEtD,aAAa,CACtB,CAAEyD,MAAM,CAACK,QAAT,EAAmBJ,MAAM,CAACI,QAA1B,CADsB,qBAIjBL,MAJiB;AAKpBS,MAAAA,UAAU,oBACNT,MAAM,CAACS,UADD,EAEND,iBAFM;AALU,kCAUlBF,qBAAqB,CAACI,KAAtB,CAA6B,CAA7B,CAVkB,GAAf,CAAR;AAaA,GA1Da;AA2DdC,EAAAA,YA3Dc,wBA2DAzC,MA3DA,EA2DQC,KA3DR,EA2DgB;AAAA,QACrByC,IADqB,GACZ1C,MADY,CACrB0C,IADqB;AAE7B,QAAMxC,KAAK,GAAGD,KAAK,CAACE,QAAN,EAAd,CAF6B,CAI7B;;AACA,QAAII,MAAM,GAAGxC,KAAK,CAAE2E,IAAI,CAACC,OAAL,CAAaC,GAAf,CAAlB,CAL6B,CAO7B;;AACA,QAAMC,SAAS,GAAGH,IAAI,CAACI,MAAL,KAAgB,YAAlC;AACA,QAAM1C,QAAQ,GAAGpB,WAAW,CAAEkB,KAAF,CAA5B;;AACA,QAAK2C,SAAS,IAAIzC,QAAlB,EAA6B;AAC5BG,MAAAA,MAAM,GAAGpC,6BAA6B,CAAEoC,MAAF,EAAUH,QAAV,CAAtC;AACA,KAZ4B,CAc7B;;;AACA,QAAM2C,KAAK,GAAG,EAAd;;AACA,QAAKF,SAAL,EAAiB;AAChBE,MAAAA,KAAK,CAACC,KAAN,GAAcN,IAAI,CAACM,KAAL,CAAWJ,GAAzB;AACA;;AAED,QAAMK,WAAW,GAAG7E,gBAAgB,CAAEsE,IAAF,EAAQnC,MAAR,EAAgBwC,KAAhB,CAApC;AAEA,WAAOlF,OAAO,CAAE,CACfoF,WADe,EAGf;AACA;AACA;AACA;AACAlD,IAAAA,wBAAwB,CAAEkD,WAAF,EAAehD,KAAf,CAPT,CAAF,CAAd;AASA,GA1Fa;AA2FdiD,EAAAA,YAAY,EAAE,CACbnD,wBADa,CA3FA;AA8FdoD,EAAAA,oBA9Fc,gCA8FQnD,MA9FR,QA8F+B;AAAA,QAAbG,QAAa,QAAbA,QAAa;AAC5C,QAAMD,KAAK,GAAGC,QAAQ,EAAtB;AACA,QAAMI,MAAM,GAAG3B,SAAS,CAAEsB,KAAF,CAAxB;AACA,QAAME,QAAQ,GAAGpB,WAAW,CAAEkB,KAAF,CAA5B;AACA,QAAMkD,gBAAgB,GAAGjF,6BAA6B,CAAEoC,MAAF,EAAUH,QAAV,CAAtD;AAEA,WAAO7B,WAAW,CAAE6E,gBAAF,CAAlB;AACA,GArGa;AAsGdC,EAAAA,qBAAqB,EAAE,+BAAErD,MAAF,EAAUC,KAAV,EAAqB;AAC3Cd,IAAAA,mBAAmB,CAAEa,MAAF,EAAUC,KAAV,CAAnB;AACA,GAxGa;AAyGdqD,EAAAA,mBAAmB,EAAE,6BAAEtD,MAAF,EAAUC,KAAV,EAAqB;AACzCb,IAAAA,kBAAkB,CAAEY,MAAF,EAAUC,KAAV,CAAlB;AACA,GA3Ga;AA4GdsD,EAAAA,qBAAqB,EAAE,+BAAEvD,MAAF,EAAUC,KAAV,EAAqB;AAC3CZ,IAAAA,oBAAoB,CAAEW,MAAF,EAAUC,KAAV,CAApB;AACA,GA9Ga;AA+GduD,EAAAA,uBAAuB,EAAEhE,qBA/GX;AAgHdiE,EAAAA,uBAAuB,EAAElE,oBAhHX;AAiHdmE,EAAAA,yBAAyB,EAAEpE,sBAjHb;AAkHdqE,EAAAA,aAAa,EAAE,CACdnD,mBADc,EAEdW,kBAFc,CAlHD;AAsHdyC,EAAAA,cAAc,EAAE,CACfzC,kBADe;AAtHF,CAAf","sourcesContent":["/**\n * External dependencies\n */\nimport { compact, last } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport {\n\tparse,\n\tgetBlockType,\n\tswitchToBlockType,\n\tdoBlocksMatchTemplate,\n\tsynchronizeBlocksWithTemplate,\n} from '@wordpress/blocks';\n\n/**\n * Internal dependencies\n */\nimport {\n\tsetupEditorState,\n\treplaceBlocks,\n\tselectBlock,\n\tresetBlocks,\n\tsetTemplateValidity,\n\tinsertDefaultBlock,\n} from './actions';\nimport {\n\tgetBlock,\n\tgetBlockRootClientId,\n\tgetBlocks,\n\tgetBlockCount,\n\tgetPreviousBlockClientId,\n\tgetSelectedBlock,\n\tgetTemplate,\n\tgetTemplateLock,\n\tisValidTemplate,\n} from './selectors';\nimport {\n\tfetchReusableBlocks,\n\tsaveReusableBlocks,\n\tdeleteReusableBlocks,\n\tconvertBlockToReusable,\n\tconvertBlockToStatic,\n\treceiveReusableBlocks,\n} from './effects/reusable-blocks';\nimport {\n\trequestPostUpdate,\n\trequestPostUpdateSuccess,\n\trequestPostUpdateFailure,\n\ttrashPost,\n\ttrashPostFailure,\n\trefreshPost,\n} from './effects/posts';\n\n/**\n * Block validity is a function of blocks state (at the point of a\n * reset) and the template setting. As a compromise to its placement\n * across distinct parts of state, it is implemented here as a side-\n * effect of the block reset action.\n *\n * @param {Object} action RESET_BLOCKS action.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} New validity set action if validity has changed.\n */\nexport function validateBlocksToTemplate( action, store ) {\n\tconst state = store.getState();\n\tconst template = getTemplate( state );\n\tconst templateLock = getTemplateLock( state );\n\n\t// Unlocked templates are considered always valid because they act\n\t// as default values only.\n\tconst isBlocksValidToTemplate = (\n\t\t! template ||\n\t\ttemplateLock !== 'all' ||\n\t\tdoBlocksMatchTemplate( action.blocks, template )\n\t);\n\n\t// Update if validity has changed.\n\tif ( isBlocksValidToTemplate !== isValidTemplate( state ) ) {\n\t\treturn setTemplateValidity( isBlocksValidToTemplate );\n\t}\n}\n\n/**\n * Effect handler which will return a block select action to select the block\n * occurring before the selected block in the previous state, unless it is the\n * same block or the action includes a falsey `selectPrevious` option flag.\n *\n * @param {Object} action Action which had initiated the effect handler.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} Block select action to select previous, if applicable.\n */\nexport function selectPreviousBlock( action, store ) {\n\t// if the action says previous block should not be selected don't do anything.\n\tif ( ! action.selectPrevious ) {\n\t\treturn;\n\t}\n\n\tconst firstRemovedBlockClientId = action.clientIds[ 0 ];\n\tconst state = store.getState();\n\tconst currentSelectedBlock = getSelectedBlock( state );\n\n\t// recreate the state before the block was removed.\n\tconst previousState = { ...state, editor: { present: last( state.editor.past ) } };\n\n\t// rootClientId of the removed block.\n\tconst rootClientId = getBlockRootClientId( previousState, firstRemovedBlockClientId );\n\n\t// Client ID of the block that was before the removed block or the\n\t// rootClientId if the removed block was first amongst its siblings.\n\tconst blockClientIdToSelect = getPreviousBlockClientId( previousState, firstRemovedBlockClientId ) || rootClientId;\n\n\t// Dispatch select block action if the currently selected block\n\t// is not already the block we want to be selected.\n\tif ( blockClientIdToSelect !== currentSelectedBlock ) {\n\t\treturn selectBlock( blockClientIdToSelect, -1 );\n\t}\n}\n\n/**\n * Effect handler which will return a default block insertion action if there\n * are no other blocks at the root of the editor. This is expected to be used\n * in actions which may result in no blocks remaining in the editor (removal,\n * replacement, etc).\n *\n * @param {Object} action Action which had initiated the effect handler.\n * @param {Object} store  Store instance.\n *\n * @return {?Object} Default block insert action, if no other blocks exist.\n */\nexport function ensureDefaultBlock( action, store ) {\n\tif ( ! getBlockCount( store.getState() ) ) {\n\t\treturn insertDefaultBlock();\n\t}\n}\n\nexport default {\n\tREQUEST_POST_UPDATE: ( action, store ) => {\n\t\trequestPostUpdate( action, store );\n\t},\n\tREQUEST_POST_UPDATE_SUCCESS: requestPostUpdateSuccess,\n\tREQUEST_POST_UPDATE_FAILURE: requestPostUpdateFailure,\n\tTRASH_POST: ( action, store ) => {\n\t\ttrashPost( action, store );\n\t},\n\tTRASH_POST_FAILURE: trashPostFailure,\n\tREFRESH_POST: ( action, store ) => {\n\t\trefreshPost( action, store );\n\t},\n\tMERGE_BLOCKS( action, store ) {\n\t\tconst { dispatch } = store;\n\t\tconst state = store.getState();\n\t\tconst [ firstBlockClientId, secondBlockClientId ] = action.blocks;\n\t\tconst blockA = getBlock( state, firstBlockClientId );\n\t\tconst blockB = getBlock( state, secondBlockClientId );\n\t\tconst blockType = getBlockType( blockA.name );\n\n\t\t// Only focus the previous block if it's not mergeable\n\t\tif ( ! blockType.merge ) {\n\t\t\tdispatch( selectBlock( blockA.clientId ) );\n\t\t\treturn;\n\t\t}\n\n\t\t// We can only merge blocks with similar types\n\t\t// thus, we transform the block to merge first\n\t\tconst blocksWithTheSameType = blockA.name === blockB.name ?\n\t\t\t[ blockB ] :\n\t\t\tswitchToBlockType( blockB, blockA.name );\n\n\t\t// If the block types can not match, do nothing\n\t\tif ( ! blocksWithTheSameType || ! blocksWithTheSameType.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calling the merge to update the attributes and remove the block to be merged\n\t\tconst updatedAttributes = blockType.merge(\n\t\t\tblockA.attributes,\n\t\t\tblocksWithTheSameType[ 0 ].attributes\n\t\t);\n\n\t\tdispatch( selectBlock( blockA.clientId, -1 ) );\n\t\tdispatch( replaceBlocks(\n\t\t\t[ blockA.clientId, blockB.clientId ],\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t...blockA,\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t...blockA.attributes,\n\t\t\t\t\t\t...updatedAttributes,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t...blocksWithTheSameType.slice( 1 ),\n\t\t\t]\n\t\t) );\n\t},\n\tSETUP_EDITOR( action, store ) {\n\t\tconst { post } = action;\n\t\tconst state = store.getState();\n\n\t\t// Parse content as blocks\n\t\tlet blocks = parse( post.content.raw );\n\n\t\t// Apply a template for new posts only, if exists.\n\t\tconst isNewPost = post.status === 'auto-draft';\n\t\tconst template = getTemplate( state );\n\t\tif ( isNewPost && template ) {\n\t\t\tblocks = synchronizeBlocksWithTemplate( blocks, template );\n\t\t}\n\n\t\t// Include auto draft title in edits while not flagging post as dirty\n\t\tconst edits = {};\n\t\tif ( isNewPost ) {\n\t\t\tedits.title = post.title.raw;\n\t\t}\n\n\t\tconst setupAction = setupEditorState( post, blocks, edits );\n\n\t\treturn compact( [\n\t\t\tsetupAction,\n\n\t\t\t// TODO: This is temporary, necessary only so long as editor setup\n\t\t\t// is a separate action from block resetting.\n\t\t\t//\n\t\t\t// See: https://github.com/WordPress/gutenberg/pull/9403\n\t\t\tvalidateBlocksToTemplate( setupAction, store ),\n\t\t] );\n\t},\n\tRESET_BLOCKS: [\n\t\tvalidateBlocksToTemplate,\n\t],\n\tSYNCHRONIZE_TEMPLATE( action, { getState } ) {\n\t\tconst state = getState();\n\t\tconst blocks = getBlocks( state );\n\t\tconst template = getTemplate( state );\n\t\tconst updatedBlockList = synchronizeBlocksWithTemplate( blocks, template );\n\n\t\treturn resetBlocks( updatedBlockList );\n\t},\n\tFETCH_REUSABLE_BLOCKS: ( action, store ) => {\n\t\tfetchReusableBlocks( action, store );\n\t},\n\tSAVE_REUSABLE_BLOCK: ( action, store ) => {\n\t\tsaveReusableBlocks( action, store );\n\t},\n\tDELETE_REUSABLE_BLOCK: ( action, store ) => {\n\t\tdeleteReusableBlocks( action, store );\n\t},\n\tRECEIVE_REUSABLE_BLOCKS: receiveReusableBlocks,\n\tCONVERT_BLOCK_TO_STATIC: convertBlockToStatic,\n\tCONVERT_BLOCK_TO_REUSABLE: convertBlockToReusable,\n\tREMOVE_BLOCKS: [\n\t\tselectPreviousBlock,\n\t\tensureDefaultBlock,\n\t],\n\tREPLACE_BLOCKS: [\n\t\tensureDefaultBlock,\n\t],\n};\n"]}