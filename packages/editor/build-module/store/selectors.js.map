{"version":3,"sources":["/Users/ky/Sites/valet/copesacontent/web/app/plugins/gutenberg/packages/editor/src/store/selectors.js"],"names":["castArray","flatMap","find","first","get","has","includes","isArray","isBoolean","last","map","orderBy","reduce","size","some","createSelector","serialize","getBlockType","getBlockTypes","hasBlockSupport","hasChildBlocksWithInserterSupport","getFreeformContentHandlerName","isUnmodifiedDefaultBlock","moment","removep","select","deprecated","PREFERENCES_DEFAULTS","POST_UPDATE_TRANSACTION_ID","PERMALINK_POSTNAME_REGEX","INSERTER_UTILITY_HIGH","INSERTER_UTILITY_MEDIUM","INSERTER_UTILITY_LOW","INSERTER_UTILITY_NONE","MILLISECONDS_PER_HOUR","MILLISECONDS_PER_DAY","MILLISECONDS_PER_WEEK","EMPTY_ARRAY","hasEditorUndo","state","editor","past","length","hasEditorRedo","future","isEditedPostNew","getCurrentPost","status","isEditedPostDirty","isDirty","inSomeHistory","isCleanNewPost","currentPost","getCurrentPostType","type","getCurrentPostId","id","getCurrentPostRevisionsCount","getCurrentPostLastRevisionId","getPostEdits","present","edits","getReferenceByDistinctEdits","getCurrentPostAttribute","attributeName","post","hasOwnProperty","getEditedPostAttribute","getEditedPostContent","getAutosaveAttribute","hasAutosave","autosave","getAutosave","getEditedPostVisibility","password","isCurrentPostPending","isCurrentPostPublished","indexOf","date","isBefore","isCurrentPostScheduled","isEditedPostPublishable","isEditedPostSaveable","isSavingPost","isEditedPostEmpty","blocks","getBlocksForSerialization","name","isEditedPostAutosaveable","field","isEditedPostBeingScheduled","now","add","isAfter","isEditedPostDateFloating","modified","getBlockDependantsCacheBust","clientId","getBlockOrder","innerBlockClientId","getBlock","getBlockName","block","byClientId","attributes","result","value","key","source","getPostMeta","meta","innerBlocks","getBlocks","rootClientId","getClientIdsOfDescendants","clientIds","descendants","getClientIdsWithDescendants","topLevelIds","order","getGlobalBlockCount","blockName","count","getBlocksByClientId","getBlockCount","getBlockSelectionStart","blockSelection","start","getBlockSelectionEnd","end","getSelectedBlockCount","multiSelectedBlockCount","getMultiSelectedBlockClientIds","hasSelectedBlock","getSelectedBlockClientId","getSelectedBlock","getBlockRootClientId","getBlockHierarchyRootClientId","current","getAdjacentBlockClientId","startClientId","modifier","undefined","getFirstMultiSelectedBlockClientId","getLastMultiSelectedBlockClientId","orderSet","index","nextIndex","getPreviousBlockClientId","getNextBlockClientId","getSelectedBlocksInitialCaretPosition","initialPosition","blockOrder","startIndex","endIndex","slice","getMultiSelectedBlocks","multiSelectedBlockClientIds","isFirstMultiSelectedBlock","isBlockMultiSelected","isAncestorMultiSelected","ancestorClientId","isMultiSelected","getMultiSelectedBlocksStartClientId","getMultiSelectedBlocksEndClientId","getBlockIndex","isBlockSelected","hasSelectedInnerBlock","deep","innerClientId","isBlockWithinSelection","hasMultiSelection","isMultiSelecting","isSelectionEnabled","isEnabled","getBlockMode","blocksMode","isTyping","isCaretWithinFormattedText","getBlockInsertionPoint","insertionPoint","isBlockInsertionPointVisible","isValidTemplate","template","isValid","getTemplate","settings","getTemplateLock","templateLock","blockListSettings","getBlockListSettings","saving","requesting","didPostSaveRequestSucceed","successful","didPostSaveRequestFail","error","isAutosavingPost","isAutosave","getSuggestedPostFormat","isSingleUnmodifiedDefaultBlock","content","isSingleFreeformBlock","canInsertBlockType","checkAllowList","list","item","defaultResult","blockType","getEditorSettings","allowedBlockTypes","isBlockAllowedInEditor","isLocked","parentBlockListSettings","parentAllowedBlocks","hasParentAllowedBlock","blockAllowedParentBlocks","parent","parentName","hasBlockAllowedParent","getInsertUsage","preferences","insertUsage","getInserterItems","calculateUtility","category","isContextual","calculateFrecency","time","duration","Date","shouldIncludeBlockType","buildBlockTypeInserterItem","isDisabled","initialAttributes","title","icon","keywords","utility","frecency","shouldIncludeReusableBlock","reusableBlock","referencedBlock","referencedBlockType","buildReusableBlockInserterItem","ref","blockTypeInserterItems","filter","reusableBlockInserterItems","__experimentalGetReusableBlocks","reusableBlocks","data","__experimentalGetReusableBlock","isTemporary","isNaN","parseInt","__experimentalIsSavingReusableBlock","isSaving","__experimentalIsFetchingReusableBlock","isFetching","getStateBeforeOptimisticTransaction","transactionId","transaction","optimist","entry","beforeState","action","isPublishingPost","stateBeforeRequest","isPermalinkEditable","permalinkTemplate","test","getPermalink","getPermalinkParts","prefix","postName","suffix","split","predicate","getTokenSettings","tokens","isPostLocked","postLock","isPostSavingLocked","postSavingLock","isPostLockTakeover","isTakeover","getPostLockUser","user","getActivePostLock","activePostLock","canUserUseUnfilteredHTML","isPublishSidebarEnabled","getNotices","alternative","plugin","version","getReusableBlock","isSavingReusableBlock","hint","isFetchingReusableBlock","getReusableBlocks"],"mappings":";;;;AAAA;;;AAGA,SACCA,SADD,EAECC,OAFD,EAGCC,IAHD,EAICC,KAJD,EAKCC,GALD,EAMCC,GAND,EAOCC,QAPD,EAQCC,OARD,EASCC,SATD,EAUCC,IAVD,EAWCC,GAXD,EAYCC,OAZD,EAaCC,MAbD,EAcCC,IAdD,EAeCC,IAfD,QAgBO,QAhBP;AAiBA,OAAOC,cAAP,MAA2B,QAA3B;AAEA;;;;AAGA,SACCC,SADD,EAECC,YAFD,EAGCC,aAHD,EAICC,eAJD,EAKCC,iCALD,EAMCC,6BAND,EAOCC,wBAPD,QAQO,mBARP;AASA,SAASC,MAAT,QAAuB,iBAAvB;AACA,SAASC,OAAT,QAAwB,kBAAxB;AACA,SAASC,MAAT,QAAuB,iBAAvB;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AAEA;;;;AAGA,SAASC,oBAAT,QAAqC,YAArC;AAEA;;;;AAGA,OAAO,IAAMC,0BAA0B,GAAG,aAAnC;AACP,IAAMC,wBAAwB,GAAG,yBAAjC;AACA,OAAO,IAAMC,qBAAqB,GAAG,CAA9B;AACP,OAAO,IAAMC,uBAAuB,GAAG,CAAhC;AACP,OAAO,IAAMC,oBAAoB,GAAG,CAA7B;AACP,OAAO,IAAMC,qBAAqB,GAAG,CAA9B;AACP,IAAMC,qBAAqB,GAAG,OAAO,IAArC;AACA,IAAMC,oBAAoB,GAAG,KAAK,IAAL,GAAY,IAAzC;AACA,IAAMC,qBAAqB,GAAG,IAAI,EAAJ,GAAS,IAAT,GAAgB,IAA9C;AAEA;;;;;;;;;;AASA,IAAMC,WAAW,GAAG,EAApB;AAEA;;;;;;;;AAOA,OAAO,SAASC,aAAT,CAAwBC,KAAxB,EAAgC;AACtC,SAAOA,KAAK,CAACC,MAAN,CAAaC,IAAb,CAAkBC,MAAlB,GAA2B,CAAlC;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASC,aAAT,CAAwBJ,KAAxB,EAAgC;AACtC,SAAOA,KAAK,CAACC,MAAN,CAAaI,MAAb,CAAoBF,MAApB,GAA6B,CAApC;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASG,eAAT,CAA0BN,KAA1B,EAAkC;AACxC,SAAOO,cAAc,CAAEP,KAAF,CAAd,CAAwBQ,MAAxB,KAAmC,YAA1C;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASC,iBAAT,CAA4BT,KAA5B,EAAoC;AAC1C,SAAOA,KAAK,CAACC,MAAN,CAAaS,OAAb,IAAwBC,aAAa,CAAEX,KAAF,EAASS,iBAAT,CAA5C;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASG,cAAT,CAAyBZ,KAAzB,EAAiC;AACvC,SAAO,CAAES,iBAAiB,CAAET,KAAF,CAAnB,IAAgCM,eAAe,CAAEN,KAAF,CAAtD;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASO,cAAT,CAAyBP,KAAzB,EAAiC;AACvC,SAAOA,KAAK,CAACa,WAAb;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,kBAAT,CAA6Bd,KAA7B,EAAqC;AAC3C,SAAOA,KAAK,CAACa,WAAN,CAAkBE,IAAzB;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASC,gBAAT,CAA2BhB,KAA3B,EAAmC;AACzC,SAAOO,cAAc,CAAEP,KAAF,CAAd,CAAwBiB,EAAxB,IAA8B,IAArC;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,4BAAT,CAAuClB,KAAvC,EAA+C;AACrD,SAAOnC,GAAG,CAAE0C,cAAc,CAAEP,KAAF,CAAhB,EAA2B,CAAE,QAAF,EAAY,iBAAZ,EAA+B,CAA/B,EAAkC,OAAlC,CAA3B,EAAwE,CAAxE,CAAV;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASmB,4BAAT,CAAuCnB,KAAvC,EAA+C;AACrD,SAAOnC,GAAG,CAAE0C,cAAc,CAAEP,KAAF,CAAhB,EAA2B,CAAE,QAAF,EAAY,qBAAZ,EAAmC,CAAnC,EAAsC,IAAtC,CAA3B,EAAyE,IAAzE,CAAV;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASoB,YAAT,CAAuBpB,KAAvB,EAA+B;AACrC,SAAOA,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqBC,KAA5B;AACA;AAED;;;;;;;;;;;;;;;;;;;AAkBA,OAAO,IAAMC,2BAA2B,GAAG/C,cAAc,CACxD;AAAA,SAAM,EAAN;AAAA,CADwD,EAExD,UAAEwB,KAAF;AAAA,SAAa,CAAEA,KAAK,CAACC,MAAR,CAAb;AAAA,CAFwD,CAAlD;AAKP;;;;;;;;;AAQA,OAAO,SAASuB,uBAAT,CAAkCxB,KAAlC,EAAyCyB,aAAzC,EAAyD;AAC/D,MAAMC,IAAI,GAAGnB,cAAc,CAAEP,KAAF,CAA3B;;AACA,MAAK0B,IAAI,CAACC,cAAL,CAAqBF,aAArB,CAAL,EAA4C;AAC3C,WAAOC,IAAI,CAAED,aAAF,CAAX;AACA;AACD;AAED;;;;;;;;;;;AAUA,OAAO,SAASG,sBAAT,CAAiC5B,KAAjC,EAAwCyB,aAAxC,EAAwD;AAC9D,MAAMH,KAAK,GAAGF,YAAY,CAAEpB,KAAF,CAA1B,CAD8D,CAG9D;;AACA,UAASyB,aAAT;AACC,SAAK,SAAL;AACC,aAAOI,oBAAoB,CAAE7B,KAAF,CAA3B;AAFF;;AAKA,MAAK,CAAEsB,KAAK,CAACK,cAAN,CAAsBF,aAAtB,CAAP,EAA+C;AAC9C,WAAOD,uBAAuB,CAAExB,KAAF,EAASyB,aAAT,CAA9B;AACA;;AAED,SAAOH,KAAK,CAAEG,aAAF,CAAZ;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASK,oBAAT,CAA+B9B,KAA/B,EAAsCyB,aAAtC,EAAsD;AAC5D,MAAK,CAAEM,WAAW,CAAE/B,KAAF,CAAlB,EAA8B;AAC7B,WAAO,IAAP;AACA;;AAED,MAAMgC,QAAQ,GAAGC,WAAW,CAAEjC,KAAF,CAA5B;;AACA,MAAKgC,QAAQ,CAACL,cAAT,CAAyBF,aAAzB,CAAL,EAAgD;AAC/C,WAAOO,QAAQ,CAAEP,aAAF,CAAf;AACA;AACD;AAED;;;;;;;;;;AASA,OAAO,SAASS,uBAAT,CAAkClC,KAAlC,EAA0C;AAChD,MAAMQ,MAAM,GAAGoB,sBAAsB,CAAE5B,KAAF,EAAS,QAAT,CAArC;AACA,MAAMmC,QAAQ,GAAGP,sBAAsB,CAAE5B,KAAF,EAAS,UAAT,CAAvC;;AAEA,MAAKQ,MAAM,KAAK,SAAhB,EAA4B;AAC3B,WAAO,SAAP;AACA,GAFD,MAEO,IAAK2B,QAAL,EAAgB;AACtB,WAAO,UAAP;AACA;;AACD,SAAO,QAAP;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,oBAAT,CAA+BpC,KAA/B,EAAuC;AAC7C,SAAOO,cAAc,CAAEP,KAAF,CAAd,CAAwBQ,MAAxB,KAAmC,SAA1C;AACA;AAED;;;;;;;;AAOA,OAAO,SAAS6B,sBAAT,CAAiCrC,KAAjC,EAAyC;AAC/C,MAAM0B,IAAI,GAAGnB,cAAc,CAAEP,KAAF,CAA3B;AAEA,SAAO,CAAE,SAAF,EAAa,SAAb,EAAyBsC,OAAzB,CAAkCZ,IAAI,CAAClB,MAAvC,MAAoD,CAAC,CAArD,IACJkB,IAAI,CAAClB,MAAL,KAAgB,QAAhB,IAA4BxB,MAAM,CAAE0C,IAAI,CAACa,IAAP,CAAN,CAAoBC,QAApB,CAA8BxD,MAAM,EAApC,CAD/B;AAEA;AAED;;;;;;;;AAOA,OAAO,SAASyD,sBAAT,CAAiCzC,KAAjC,EAAyC;AAC/C,SAAOO,cAAc,CAAEP,KAAF,CAAd,CAAwBQ,MAAxB,KAAmC,QAAnC,IAA+C,CAAE6B,sBAAsB,CAAErC,KAAF,CAA9E;AACA;AAED;;;;;;;;AAOA,OAAO,SAAS0C,uBAAT,CAAkC1C,KAAlC,EAA0C;AAChD,MAAM0B,IAAI,GAAGnB,cAAc,CAAEP,KAAF,CAA3B,CADgD,CAGhD;AACA;AACA;AACA;;AAEA,SAAOS,iBAAiB,CAAET,KAAF,CAAjB,IAA8B,CAAE,SAAF,EAAa,SAAb,EAAwB,QAAxB,EAAmCsC,OAAnC,CAA4CZ,IAAI,CAAClB,MAAjD,MAA8D,CAAC,CAApG;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASmC,oBAAT,CAA+B3C,KAA/B,EAAuC;AAC7C,MAAK4C,YAAY,CAAE5C,KAAF,CAAjB,EAA6B;AAC5B,WAAO,KAAP;AACA,GAH4C,CAK7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SACC,CAAC,CAAE4B,sBAAsB,CAAE5B,KAAF,EAAS,OAAT,CAAzB,IACA,CAAC,CAAE4B,sBAAsB,CAAE5B,KAAF,EAAS,SAAT,CADzB,IAEA,CAAE6C,iBAAiB,CAAE7C,KAAF,CAHpB;AAKA;AAED;;;;;;;;;;AASA,OAAO,SAAS6C,iBAAT,CAA4B7C,KAA5B,EAAoC;AAC1C,MAAM8C,MAAM,GAAGC,yBAAyB,CAAE/C,KAAF,CAAxC,CAD0C,CAG1C;AACA;AACA;AACA;AACA;;AACA,MAAK8C,MAAM,CAAC3C,MAAP,IAAiB,EAAI,aAAaiB,YAAY,CAAEpB,KAAF,CAA7B,CAAtB,EAAiE;AAChE;AACA;AACA;AACA,QAAK8C,MAAM,CAAC3C,MAAP,GAAgB,CAArB,EAAyB;AACxB,aAAO,KAAP;AACA,KAN+D,CAQhE;AACA;AACA;AACA;AACA;;;AACA,QAAK2C,MAAM,CAAE,CAAF,CAAN,CAAYE,IAAZ,KAAqBlE,6BAA6B,EAAvD,EAA4D;AAC3D,aAAO,KAAP;AACA;AACD;;AAED,SAAO,CAAE+C,oBAAoB,CAAE7B,KAAF,CAA7B;AACA;AAED;;;;;;;;AAOA,OAAO,SAASiD,wBAAT,CAAmCjD,KAAnC,EAA2C;AACjD;AACA,MAAK,CAAE2C,oBAAoB,CAAE3C,KAAF,CAA3B,EAAuC;AACtC,WAAO,KAAP;AACA,GAJgD,CAMjD;;;AACA,MAAK,CAAE+B,WAAW,CAAE/B,KAAF,CAAlB,EAA8B;AAC7B,WAAO,IAAP;AACA,GATgD,CAWjD;;;AACA,MAAMgC,QAAQ,GAAGC,WAAW,CAAEjC,KAAF,CAA5B;AACA,SAAO,CAAE,OAAF,EAAW,SAAX,EAAsB,SAAtB,EAAkCzB,IAAlC,CAAwC,UAAE2E,KAAF;AAAA,WAC9ClB,QAAQ,CAAEkB,KAAF,CAAR,KAAsBtB,sBAAsB,CAAE5B,KAAF,EAASkD,KAAT,CADE;AAAA,GAAxC,CAAP;AAGA;AAED;;;;;;;;;;AASA,OAAO,SAASjB,WAAT,CAAsBjC,KAAtB,EAA8B;AACpC,SAAOA,KAAK,CAACgC,QAAb;AACA;AAED;;;;;;;;AAOA,OAAO,SAASD,WAAT,CAAsB/B,KAAtB,EAA8B;AACpC,SAAO,CAAC,CAAEiC,WAAW,CAAEjC,KAAF,CAArB;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASmD,0BAAT,CAAqCnD,KAArC,EAA6C;AACnD,MAAMuC,IAAI,GAAGvD,MAAM,CAAE4C,sBAAsB,CAAE5B,KAAF,EAAS,MAAT,CAAxB,CAAnB,CADmD,CAEnD;;AACA,MAAMoD,GAAG,GAAGpE,MAAM,GAAGqE,GAAT,CAAc,CAAd,EAAiB,QAAjB,CAAZ;AAEA,SAAOd,IAAI,CAACe,OAAL,CAAcF,GAAd,CAAP;AACA;AAED;;;;;;;;;;;;;;AAaA,OAAO,SAASG,wBAAT,CAAmCvD,KAAnC,EAA2C;AACjD,MAAMuC,IAAI,GAAGX,sBAAsB,CAAE5B,KAAF,EAAS,MAAT,CAAnC;AACA,MAAMwD,QAAQ,GAAG5B,sBAAsB,CAAE5B,KAAF,EAAS,UAAT,CAAvC;AACA,MAAMQ,MAAM,GAAGoB,sBAAsB,CAAE5B,KAAF,EAAS,QAAT,CAArC;;AACA,MAAKQ,MAAM,KAAK,OAAX,IAAsBA,MAAM,KAAK,YAAtC,EAAqD;AACpD,WAAO+B,IAAI,KAAKiB,QAAhB;AACA;;AACD,SAAO,KAAP;AACA;AAED;;;;;;;;;;;;;;;AAcA,OAAO,IAAMC,2BAA2B,GAAGjF,cAAc,CACxD;AAAA,SAAM,EAAN;AAAA,CADwD,EAExD,UAAEwB,KAAF,EAAS0D,QAAT;AAAA,SAAuBvF,GAAG,CACzBwF,aAAa,CAAE3D,KAAF,EAAS0D,QAAT,CADY,EAEzB,UAAEE,kBAAF;AAAA,WAA0BC,QAAQ,CAAE7D,KAAF,EAAS4D,kBAAT,CAAlC;AAAA,GAFyB,CAA1B;AAAA,CAFwD,CAAlD;AAQP;;;;;;;;;;AASA,OAAO,SAASE,YAAT,CAAuB9D,KAAvB,EAA8B0D,QAA9B,EAAyC;AAC/C,MAAMK,KAAK,GAAG/D,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkB,UAA5B,CAAwCN,QAAxC,CAAd;AACA,SAAOK,KAAK,GAAGA,KAAK,CAACf,IAAT,GAAgB,IAA5B;AACA;AAED;;;;;;;;;;;;AAWA,OAAO,IAAMa,QAAQ,GAAGrF,cAAc,CACrC,UAAEwB,KAAF,EAAS0D,QAAT,EAAuB;AACtB,MAAMK,KAAK,GAAG/D,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkB,UAA5B,CAAwCN,QAAxC,CAAd;;AACA,MAAK,CAAEK,KAAP,EAAe;AACd,WAAO,IAAP;AACA;;AAJqB,MAMhBE,UANgB,GAMDF,KANC,CAMhBE,UANgB,EAQtB;AACA;AACA;AACA;;AACA,MAAMlD,IAAI,GAAGrC,YAAY,CAAEqF,KAAK,CAACf,IAAR,CAAzB;;AACA,MAAKjC,IAAL,EAAY;AACXkD,IAAAA,UAAU,GAAG5F,MAAM,CAAE0C,IAAI,CAACkD,UAAP,EAAmB,UAAEC,MAAF,EAAUC,KAAV,EAAiBC,GAAjB,EAA0B;AAC/D,UAAKD,KAAK,CAACE,MAAN,KAAiB,MAAtB,EAA+B;AAC9B,YAAKH,MAAM,KAAKD,UAAhB,EAA6B;AAC5BC,UAAAA,MAAM,qBAAQA,MAAR,CAAN;AACA;;AAEDA,QAAAA,MAAM,CAAEE,GAAF,CAAN,GAAgBE,WAAW,CAAEtE,KAAF,EAASmE,KAAK,CAACI,IAAf,CAA3B;AACA;;AAED,aAAOL,MAAP;AACA,KAVkB,EAUhBD,UAVgB,CAAnB;AAWA;;AAED,2BACIF,KADJ;AAECE,IAAAA,UAAU,EAAVA,UAFD;AAGCO,IAAAA,WAAW,EAAEC,SAAS,CAAEzE,KAAF,EAAS0D,QAAT;AAHvB;AAKA,CAjCoC,EAkCrC,UAAE1D,KAAF,EAAS0D,QAAT;AAAA,SAAuB,CACtB1D,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkB,UAA5B,CAAwCN,QAAxC,CADsB,EAEtBD,2BAA2B,CAAEzD,KAAF,EAAS0D,QAAT,CAFL,EAGtB1D,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqBC,KAArB,CAA2BiD,IAHL,EAItBvE,KAAK,CAACa,WAAN,CAAkB0D,IAJI,CAAvB;AAAA,CAlCqC,CAA/B;;AA0CP,SAASD,WAAT,CAAsBtE,KAAtB,EAA6BoE,GAA7B,EAAmC;AAClC,SAAOtG,GAAG,CAAEkC,KAAF,EAAS,CAAE,QAAF,EAAY,SAAZ,EAAuB,OAAvB,EAAgC,MAAhC,EAAwCoE,GAAxC,CAAT,CAAH,GACNvG,GAAG,CAAEmC,KAAF,EAAS,CAAE,QAAF,EAAY,SAAZ,EAAuB,OAAvB,EAAgC,MAAhC,EAAwCoE,GAAxC,CAAT,CADG,GAENvG,GAAG,CAAEmC,KAAF,EAAS,CAAE,aAAF,EAAiB,MAAjB,EAAyBoE,GAAzB,CAAT,CAFJ;AAGA;AAED;;;;;;;;;;;;;;AAYA,OAAO,IAAMK,SAAS,GAAGjG,cAAc,CACtC,UAAEwB,KAAF,EAAS0E,YAAT,EAA2B;AAC1B,SAAOvG,GAAG,CACTwF,aAAa,CAAE3D,KAAF,EAAS0E,YAAT,CADJ,EAET,UAAEhB,QAAF;AAAA,WAAgBG,QAAQ,CAAE7D,KAAF,EAAS0D,QAAT,CAAxB;AAAA,GAFS,CAAV;AAIA,CANqC,EAOtC,UAAE1D,KAAF;AAAA,SAAa,CACZA,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MADT,CAAb;AAAA,CAPsC,CAAhC;AAYP;;;;;;;;;;AASA,OAAO,IAAM6B,yBAAyB,GAAG,SAA5BA,yBAA4B,CAAE3E,KAAF,EAAS4E,SAAT;AAAA,SAAwBlH,OAAO,CAAEkH,SAAF,EAAa,UAAElB,QAAF,EAAgB;AACpG,QAAMmB,WAAW,GAAGlB,aAAa,CAAE3D,KAAF,EAAS0D,QAAT,CAAjC;AACA,8BAAYmB,WAAZ,4BAA4BF,yBAAyB,CAAE3E,KAAF,EAAS6E,WAAT,CAArD;AACA,GAHuE,CAA/B;AAAA,CAAlC;AAKP;;;;;;;;;AAQA,OAAO,IAAMC,2BAA2B,GAAGtG,cAAc,CACxD,UAAEwB,KAAF,EAAa;AACZ,MAAM+E,WAAW,GAAGpB,aAAa,CAAE3D,KAAF,CAAjC;AACA,4BAAY+E,WAAZ,4BAA4BJ,yBAAyB,CAAE3E,KAAF,EAAS+E,WAAT,CAArD;AACA,CAJuD,EAKxD,UAAE/E,KAAF;AAAA,SAAa,CACZA,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkC,KADhB,CAAb;AAAA,CALwD,CAAlD;AAUP;;;;;;;;;;AASA,OAAO,IAAMC,mBAAmB,GAAGzG,cAAc,CAChD,UAAEwB,KAAF,EAASkF,SAAT,EAAwB;AACvB,MAAK,CAAEA,SAAP,EAAmB;AAClB,WAAO5G,IAAI,CAAE0B,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkB,UAA9B,CAAX;AACA;;AACD,SAAO3F,MAAM,CACZ2B,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkB,UADhB,EAEZ,UAAEmB,KAAF,EAASpB,KAAT;AAAA,WAAoBA,KAAK,CAACf,IAAN,KAAekC,SAAf,GAA2BC,KAAK,GAAG,CAAnC,GAAuCA,KAA3D;AAAA,GAFY,EAGZ,CAHY,CAAb;AAKA,CAV+C,EAWhD,UAAEnF,KAAF;AAAA,SAAa,CACZA,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkB,UADhB,CAAb;AAAA,CAXgD,CAA1C;AAgBP;;;;;;;;;;AASA,OAAO,IAAMoB,mBAAmB,GAAG5G,cAAc,CAChD,UAAEwB,KAAF,EAAS4E,SAAT;AAAA,SAAwBzG,GAAG,CAC1BV,SAAS,CAAEmH,SAAF,CADiB,EAE1B,UAAElB,QAAF;AAAA,WAAgBG,QAAQ,CAAE7D,KAAF,EAAS0D,QAAT,CAAxB;AAAA,GAF0B,CAA3B;AAAA,CADgD,EAKhD,UAAE1D,KAAF;AAAA,SAAa,CACZA,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqBC,KAArB,CAA2BiD,IADf,EAEZvE,KAAK,CAACa,WAAN,CAAkB0D,IAFN,EAGZvE,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAHT,CAAb;AAAA,CALgD,CAA1C;AAYP;;;;;;;;;AAQA,OAAO,SAASuC,aAAT,CAAwBrF,KAAxB,EAA+B0E,YAA/B,EAA8C;AACpD,SAAOf,aAAa,CAAE3D,KAAF,EAAS0E,YAAT,CAAb,CAAqCvE,MAA5C;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASmF,sBAAT,CAAiCtF,KAAjC,EAAyC;AAC/C,SAAOA,KAAK,CAACuF,cAAN,CAAqBC,KAA5B;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASC,oBAAT,CAA+BzF,KAA/B,EAAuC;AAC7C,SAAOA,KAAK,CAACuF,cAAN,CAAqBG,GAA5B;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,qBAAT,CAAgC3F,KAAhC,EAAwC;AAC9C,MAAM4F,uBAAuB,GAAGC,8BAA8B,CAAE7F,KAAF,CAA9B,CAAwCG,MAAxE;;AAEA,MAAKyF,uBAAL,EAA+B;AAC9B,WAAOA,uBAAP;AACA;;AAED,SAAO5F,KAAK,CAACuF,cAAN,CAAqBC,KAArB,GAA6B,CAA7B,GAAiC,CAAxC;AACA;AAED;;;;;;;;AAOA,OAAO,SAASM,gBAAT,CAA2B9F,KAA3B,EAAmC;AAAA,8BAClBA,KAAK,CAACuF,cADY;AAAA,MACjCC,KADiC,yBACjCA,KADiC;AAAA,MAC1BE,GAD0B,yBAC1BA,GAD0B;AAEzC,SAAO,CAAC,CAAEF,KAAH,IAAYA,KAAK,KAAKE,GAA7B;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASK,wBAAT,CAAmC/F,KAAnC,EAA2C;AAAA,+BAC1BA,KAAK,CAACuF,cADoB;AAAA,MACzCC,KADyC,0BACzCA,KADyC;AAAA,MAClCE,GADkC,0BAClCA,GADkC;AAEjD,SAAOF,KAAK,KAAKE,GAAV,IAAiBF,KAAjB,GAAyBA,KAAzB,GAAiC,IAAxC;AACA;AAED;;;;;;;;AAOA,OAAO,SAASQ,gBAAT,CAA2BhG,KAA3B,EAAmC;AACzC,MAAM0D,QAAQ,GAAGqC,wBAAwB,CAAE/F,KAAF,CAAzC;AACA,SAAO0D,QAAQ,GAAGG,QAAQ,CAAE7D,KAAF,EAAS0D,QAAT,CAAX,GAAiC,IAAhD;AACA;AAED;;;;;;;;;;;AAUA,OAAO,IAAMuC,oBAAoB,GAAGzH,cAAc,CACjD,UAAEwB,KAAF,EAAS0D,QAAT,EAAuB;AAAA,MACdsB,KADc,GACJhF,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MADjB,CACdkC,KADc;;AAGtB,OAAM,IAAMN,YAAZ,IAA4BM,KAA5B,EAAoC;AACnC,QAAKjH,QAAQ,CAAEiH,KAAK,CAAEN,YAAF,CAAP,EAAyBhB,QAAzB,CAAb,EAAmD;AAClD,aAAOgB,YAAP;AACA;AACD;;AAED,SAAO,IAAP;AACA,CAXgD,EAYjD,UAAE1E,KAAF;AAAA,SAAa,CACZA,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkC,KADhB,CAAb;AAAA,CAZiD,CAA3C;AAiBP;;;;;;;;;AAQA,OAAO,IAAMkB,6BAA6B,GAAG1H,cAAc,CAC1D,UAAEwB,KAAF,EAAS0D,QAAT,EAAuB;AACtB,MAAIgB,YAAY,GAAGhB,QAAnB;AACA,MAAIyC,OAAO,GAAGzC,QAAd;;AACA,SAAQgB,YAAR,EAAuB;AACtByB,IAAAA,OAAO,GAAGzB,YAAV;AACAA,IAAAA,YAAY,GAAGuB,oBAAoB,CAAEjG,KAAF,EAASmG,OAAT,CAAnC;AACA;;AAED,SAAOA,OAAP;AACA,CAVyD,EAW1D,UAAEnG,KAAF;AAAA,SAAa,CACZA,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkC,KADhB,CAAb;AAAA,CAX0D,CAApD;AAgBP;;;;;;;;;;;;;;;AAcA,OAAO,SAASoB,wBAAT,CAAmCpG,KAAnC,EAA0CqG,aAA1C,EAAwE;AAAA,MAAfC,QAAe,uEAAJ,CAAI;;AAC9E;AACA,MAAKD,aAAa,KAAKE,SAAvB,EAAmC;AAClCF,IAAAA,aAAa,GAAGN,wBAAwB,CAAE/F,KAAF,CAAxC;AACA,GAJ6E,CAM9E;;;AACA,MAAKqG,aAAa,KAAKE,SAAvB,EAAmC;AAClC,QAAKD,QAAQ,GAAG,CAAhB,EAAoB;AACnBD,MAAAA,aAAa,GAAGG,kCAAkC,CAAExG,KAAF,CAAlD;AACA,KAFD,MAEO;AACNqG,MAAAA,aAAa,GAAGI,iCAAiC,CAAEzG,KAAF,CAAjD;AACA;AACD,GAb6E,CAe9E;;;AACA,MAAK,CAAEqG,aAAP,EAAuB;AACtB,WAAO,IAAP;AACA,GAlB6E,CAoB9E;AACA;;;AACA,MAAM3B,YAAY,GAAGuB,oBAAoB,CAAEjG,KAAF,EAASqG,aAAT,CAAzC;;AACA,MAAK3B,YAAY,KAAK,IAAtB,EAA6B;AAC5B,WAAO,IAAP;AACA;;AAzB6E,MA2BtEM,KA3BsE,GA2B5DhF,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MA3BuC,CA2BtEkC,KA3BsE;AA4B9E,MAAM0B,QAAQ,GAAG1B,KAAK,CAAEN,YAAF,CAAtB;AACA,MAAMiC,KAAK,GAAGD,QAAQ,CAACpE,OAAT,CAAkB+D,aAAlB,CAAd;AACA,MAAMO,SAAS,GAAKD,KAAK,GAAK,IAAIL,QAAlC,CA9B8E,CAgC9E;;AACA,MAAKM,SAAS,GAAG,CAAjB,EAAqB;AACpB,WAAO,IAAP;AACA,GAnC6E,CAqC9E;;;AACA,MAAKA,SAAS,KAAKF,QAAQ,CAACvG,MAA5B,EAAqC;AACpC,WAAO,IAAP;AACA,GAxC6E,CA0C9E;;;AACA,SAAOuG,QAAQ,CAAEE,SAAF,CAAf;AACA;AAED;;;;;;;;;;;;AAWA,OAAO,SAASC,wBAAT,CAAmC7G,KAAnC,EAA0CqG,aAA1C,EAA0D;AAChE,SAAOD,wBAAwB,CAAEpG,KAAF,EAASqG,aAAT,EAAwB,CAAC,CAAzB,CAA/B;AACA;AAED;;;;;;;;;;;;AAWA,OAAO,SAASS,oBAAT,CAA+B9G,KAA/B,EAAsCqG,aAAtC,EAAsD;AAC5D,SAAOD,wBAAwB,CAAEpG,KAAF,EAASqG,aAAT,EAAwB,CAAxB,CAA/B;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASU,qCAAT,CAAgD/G,KAAhD,EAAwD;AAAA,+BACvCA,KAAK,CAACuF,cADiC;AAAA,MACtDC,KADsD,0BACtDA,KADsD;AAAA,MAC/CE,GAD+C,0BAC/CA,GAD+C;;AAE9D,MAAKF,KAAK,KAAKE,GAAV,IAAiB,CAAEF,KAAxB,EAAgC;AAC/B,WAAO,IAAP;AACA;;AAED,SAAOxF,KAAK,CAACuF,cAAN,CAAqByB,eAA5B;AACA;AAED;;;;;;;;;AAQA,OAAO,IAAMnB,8BAA8B,GAAGrH,cAAc,CAC3D,UAAEwB,KAAF,EAAa;AAAA,+BACWA,KAAK,CAACuF,cADjB;AAAA,MACJC,KADI,0BACJA,KADI;AAAA,MACGE,GADH,0BACGA,GADH;;AAEZ,MAAKF,KAAK,KAAKE,GAAf,EAAqB;AACpB,WAAO,EAAP;AACA,GAJW,CAMZ;AACA;AACA;;;AACA,MAAMhB,YAAY,GAAGuB,oBAAoB,CAAEjG,KAAF,EAASwF,KAAT,CAAzC;;AACA,MAAKd,YAAY,KAAK,IAAtB,EAA6B;AAC5B,WAAO,EAAP;AACA;;AAED,MAAMuC,UAAU,GAAGtD,aAAa,CAAE3D,KAAF,EAAS0E,YAAT,CAAhC;AACA,MAAMwC,UAAU,GAAGD,UAAU,CAAC3E,OAAX,CAAoBkD,KAApB,CAAnB;AACA,MAAM2B,QAAQ,GAAGF,UAAU,CAAC3E,OAAX,CAAoBoD,GAApB,CAAjB;;AAEA,MAAKwB,UAAU,GAAGC,QAAlB,EAA6B;AAC5B,WAAOF,UAAU,CAACG,KAAX,CAAkBD,QAAlB,EAA4BD,UAAU,GAAG,CAAzC,CAAP;AACA;;AAED,SAAOD,UAAU,CAACG,KAAX,CAAkBF,UAAlB,EAA8BC,QAAQ,GAAG,CAAzC,CAAP;AACA,CAxB0D,EAyB3D,UAAEnH,KAAF;AAAA,SAAa,CACZA,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkC,KADhB,EAEZhF,KAAK,CAACuF,cAAN,CAAqBC,KAFT,EAGZxF,KAAK,CAACuF,cAAN,CAAqBG,GAHT,CAAb;AAAA,CAzB2D,CAArD;AAgCP;;;;;;;;;AAQA,OAAO,IAAM2B,sBAAsB,GAAG7I,cAAc,CACnD,UAAEwB,KAAF,EAAa;AACZ,MAAMsH,2BAA2B,GAAGzB,8BAA8B,CAAE7F,KAAF,CAAlE;;AACA,MAAK,CAAEsH,2BAA2B,CAACnH,MAAnC,EAA4C;AAC3C,WAAOL,WAAP;AACA;;AAED,SAAOwH,2BAA2B,CAACnJ,GAA5B,CAAiC,UAAEuF,QAAF;AAAA,WAAgBG,QAAQ,CAAE7D,KAAF,EAAS0D,QAAT,CAAxB;AAAA,GAAjC,CAAP;AACA,CARkD,EASnD,UAAE1D,KAAF;AAAA,SAAa,CACZA,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkC,KADhB,EAEZhF,KAAK,CAACuF,cAAN,CAAqBC,KAFT,EAGZxF,KAAK,CAACuF,cAAN,CAAqBG,GAHT,EAIZ1F,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkB,UAJhB,EAKZhE,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqBC,KAArB,CAA2BiD,IALf,EAMZvE,KAAK,CAACa,WAAN,CAAkB0D,IANN,CAAb;AAAA,CATmD,CAA7C;AAmBP;;;;;;;;;AAQA,OAAO,SAASiC,kCAAT,CAA6CxG,KAA7C,EAAqD;AAC3D,SAAOpC,KAAK,CAAEiI,8BAA8B,CAAE7F,KAAF,CAAhC,CAAL,IAAoD,IAA3D;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASyG,iCAAT,CAA4CzG,KAA5C,EAAoD;AAC1D,SAAO9B,IAAI,CAAE2H,8BAA8B,CAAE7F,KAAF,CAAhC,CAAJ,IAAmD,IAA1D;AACA;AAED;;;;;;;;;;;AAUA,OAAO,SAASuH,yBAAT,CAAoCvH,KAApC,EAA2C0D,QAA3C,EAAsD;AAC5D,SAAO8C,kCAAkC,CAAExG,KAAF,CAAlC,KAAgD0D,QAAvD;AACA;AAED;;;;;;;;;;AASA,OAAO,SAAS8D,oBAAT,CAA+BxH,KAA/B,EAAsC0D,QAAtC,EAAiD;AACvD,SAAOmC,8BAA8B,CAAE7F,KAAF,CAA9B,CAAwCsC,OAAxC,CAAiDoB,QAAjD,MAAgE,CAAC,CAAxE;AACA;AAED;;;;;;;;;;;AAUA,OAAO,IAAM+D,uBAAuB,GAAGjJ,cAAc,CACpD,UAAEwB,KAAF,EAAS0D,QAAT,EAAuB;AACtB,MAAIgE,gBAAgB,GAAGhE,QAAvB;AACA,MAAIiE,eAAe,GAAG,KAAtB;;AACA,SAAQD,gBAAgB,IAAI,CAAEC,eAA9B,EAAgD;AAC/CD,IAAAA,gBAAgB,GAAGzB,oBAAoB,CAAEjG,KAAF,EAAS0H,gBAAT,CAAvC;AACAC,IAAAA,eAAe,GAAGH,oBAAoB,CAAExH,KAAF,EAAS0H,gBAAT,CAAtC;AACA;;AACD,SAAOC,eAAP;AACA,CATmD,EAUpD,UAAE3H,KAAF;AAAA,SAAa,CACZA,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkC,KADhB,EAEZhF,KAAK,CAACuF,cAAN,CAAqBC,KAFT,EAGZxF,KAAK,CAACuF,cAAN,CAAqBG,GAHT,CAAb;AAAA,CAVoD,CAA9C;AAgBP;;;;;;;;;;;;;AAYA,OAAO,SAASkC,mCAAT,CAA8C5H,KAA9C,EAAsD;AAAA,+BACrCA,KAAK,CAACuF,cAD+B;AAAA,MACpDC,KADoD,0BACpDA,KADoD;AAAA,MAC7CE,GAD6C,0BAC7CA,GAD6C;;AAE5D,MAAKF,KAAK,KAAKE,GAAf,EAAqB;AACpB,WAAO,IAAP;AACA;;AACD,SAAOF,KAAK,IAAI,IAAhB;AACA;AAED;;;;;;;;;;;;;AAYA,OAAO,SAASqC,iCAAT,CAA4C7H,KAA5C,EAAoD;AAAA,+BACnCA,KAAK,CAACuF,cAD6B;AAAA,MAClDC,KADkD,0BAClDA,KADkD;AAAA,MAC3CE,GAD2C,0BAC3CA,GAD2C;;AAE1D,MAAKF,KAAK,KAAKE,GAAf,EAAqB;AACpB,WAAO,IAAP;AACA;;AACD,SAAOA,GAAG,IAAI,IAAd;AACA;AAED;;;;;;;;;;;AAUA,OAAO,SAAS/B,aAAT,CAAwB3D,KAAxB,EAA+B0E,YAA/B,EAA8C;AACpD,SAAO1E,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkC,KAA5B,CAAmCN,YAAY,IAAI,EAAnD,KAA2D5E,WAAlE;AACA;AAED;;;;;;;;;;;AAUA,OAAO,SAASgI,aAAT,CAAwB9H,KAAxB,EAA+B0D,QAA/B,EAAyCgB,YAAzC,EAAwD;AAC9D,SAAOf,aAAa,CAAE3D,KAAF,EAAS0E,YAAT,CAAb,CAAqCpC,OAArC,CAA8CoB,QAA9C,CAAP;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASqE,eAAT,CAA0B/H,KAA1B,EAAiC0D,QAAjC,EAA4C;AAAA,+BAC3B1D,KAAK,CAACuF,cADqB;AAAA,MAC1CC,KAD0C,0BAC1CA,KAD0C;AAAA,MACnCE,GADmC,0BACnCA,GADmC;;AAGlD,MAAKF,KAAK,KAAKE,GAAf,EAAqB;AACpB,WAAO,KAAP;AACA;;AAED,SAAOF,KAAK,KAAK9B,QAAjB;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASsE,qBAAT,CAAgChI,KAAhC,EAAuC0D,QAAvC,EAAgE;AAAA,MAAfuE,IAAe,uEAAR,KAAQ;AACtE,SAAO1J,IAAI,CACVoF,aAAa,CAAE3D,KAAF,EAAS0D,QAAT,CADH,EAEV,UAAEwE,aAAF;AAAA,WACCH,eAAe,CAAE/H,KAAF,EAASkI,aAAT,CAAf,IACAV,oBAAoB,CAAExH,KAAF,EAASkI,aAAT,CADpB,IAEED,IAAI,IAAID,qBAAqB,CAAEhI,KAAF,EAASkI,aAAT,EAAwBD,IAAxB,CAHhC;AAAA,GAFU,CAAX;AAQA;AAED;;;;;;;;;;;;;AAYA,OAAO,SAASE,sBAAT,CAAiCnI,KAAjC,EAAwC0D,QAAxC,EAAmD;AACzD,MAAK,CAAEA,QAAP,EAAkB;AACjB,WAAO,KAAP;AACA;;AAED,MAAMkB,SAAS,GAAGiB,8BAA8B,CAAE7F,KAAF,CAAhD;AACA,MAAM2G,KAAK,GAAG/B,SAAS,CAACtC,OAAV,CAAmBoB,QAAnB,CAAd;AACA,SAAOiD,KAAK,GAAG,CAAC,CAAT,IAAcA,KAAK,GAAG/B,SAAS,CAACzE,MAAV,GAAmB,CAAhD;AACA;AAED;;;;;;;;AAOA,OAAO,SAASiI,iBAAT,CAA4BpI,KAA5B,EAAoC;AAAA,+BACnBA,KAAK,CAACuF,cADa;AAAA,MAClCC,KADkC,0BAClCA,KADkC;AAAA,MAC3BE,GAD2B,0BAC3BA,GAD2B;AAE1C,SAAOF,KAAK,KAAKE,GAAjB;AACA;AAED;;;;;;;;;;;;AAWA,OAAO,SAAS2C,gBAAT,CAA2BrI,KAA3B,EAAmC;AACzC,SAAOA,KAAK,CAACuF,cAAN,CAAqB8C,gBAA5B;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,kBAAT,CAA6BtI,KAA7B,EAAqC;AAC3C,SAAOA,KAAK,CAACuF,cAAN,CAAqBgD,SAA5B;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASC,YAAT,CAAuBxI,KAAvB,EAA8B0D,QAA9B,EAAyC;AAC/C,SAAO1D,KAAK,CAACyI,UAAN,CAAkB/E,QAAlB,KAAgC,QAAvC;AACA;AAED;;;;;;;;AAOA,OAAO,SAASgF,QAAT,CAAmB1I,KAAnB,EAA2B;AACjC,SAAOA,KAAK,CAAC0I,QAAb;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,0BAAT,CAAqC3I,KAArC,EAA6C;AACnD,SAAOA,KAAK,CAAC2I,0BAAb;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASC,sBAAT,CAAiC5I,KAAjC,EAAyC;AAC/C,MAAI0E,YAAJ,EAAkBiC,KAAlB;AAD+C,MAGvCkC,cAHuC,GAGJ7I,KAHI,CAGvC6I,cAHuC;AAAA,MAGvBtD,cAHuB,GAGJvF,KAHI,CAGvBuF,cAHuB;;AAI/C,MAAKsD,cAAc,KAAK,IAAxB,EAA+B;AAC9B,WAAOA,cAAP;AACA;;AAN8C,MAQvCnD,GARuC,GAQ/BH,cAR+B,CAQvCG,GARuC;;AAS/C,MAAKA,GAAL,EAAW;AACVhB,IAAAA,YAAY,GAAGuB,oBAAoB,CAAEjG,KAAF,EAAS0F,GAAT,CAApB,IAAsCa,SAArD;AACAI,IAAAA,KAAK,GAAGmB,aAAa,CAAE9H,KAAF,EAAS0F,GAAT,EAAchB,YAAd,CAAb,GAA4C,CAApD;AACA,GAHD,MAGO;AACNiC,IAAAA,KAAK,GAAGhD,aAAa,CAAE3D,KAAF,CAAb,CAAuBG,MAA/B;AACA;;AAED,SAAO;AAAEuE,IAAAA,YAAY,EAAZA,YAAF;AAAgBiC,IAAAA,KAAK,EAALA;AAAhB,GAAP;AACA;AAED;;;;;;;;AAOA,OAAO,SAASmC,4BAAT,CAAuC9I,KAAvC,EAA+C;AACrD,SAAOA,KAAK,CAAC6I,cAAN,KAAyB,IAAhC;AACA;AAED;;;;;;;AAMA,OAAO,SAASE,eAAT,CAA0B/I,KAA1B,EAAkC;AACxC,SAAOA,KAAK,CAACgJ,QAAN,CAAeC,OAAtB;AACA;AAED;;;;;;;AAMA,OAAO,SAASC,WAAT,CAAsBlJ,KAAtB,EAA8B;AACpC,SAAOA,KAAK,CAACmJ,QAAN,CAAeH,QAAtB;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASI,eAAT,CAA0BpJ,KAA1B,EAAiC0E,YAAjC,EAAgD;AACtD,MAAK,CAAEA,YAAP,EAAsB;AACrB,WAAO1E,KAAK,CAACmJ,QAAN,CAAeE,YAAtB;AACA;;AAED,MAAMC,iBAAiB,GAAGC,oBAAoB,CAAEvJ,KAAF,EAAS0E,YAAT,CAA9C;;AACA,MAAK,CAAE4E,iBAAP,EAA2B;AAC1B,WAAO,IAAP;AACA;;AAED,SAAOA,iBAAiB,CAACD,YAAzB;AACA;AAED;;;;;;;;AAOA,OAAO,SAASzG,YAAT,CAAuB5C,KAAvB,EAA+B;AACrC,SAAOA,KAAK,CAACwJ,MAAN,CAAaC,UAApB;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASC,yBAAT,CAAoC1J,KAApC,EAA4C;AAClD,SAAOA,KAAK,CAACwJ,MAAN,CAAaG,UAApB;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASC,sBAAT,CAAiC5J,KAAjC,EAAyC;AAC/C,SAAO,CAAC,CAAEA,KAAK,CAACwJ,MAAN,CAAaK,KAAvB;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,gBAAT,CAA2B9J,KAA3B,EAAmC;AACzC,SAAO4C,YAAY,CAAE5C,KAAF,CAAZ,IAAyBA,KAAK,CAACwJ,MAAN,CAAaO,UAA7C;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASC,sBAAT,CAAiChK,KAAjC,EAAyC;AAC/C,MAAM8C,MAAM,GAAGa,aAAa,CAAE3D,KAAF,CAA5B;AAEA,MAAIgD,IAAJ,CAH+C,CAI/C;AACA;;AACA,MAAKF,MAAM,CAAC3C,MAAP,KAAkB,CAAvB,EAA2B;AAC1B6C,IAAAA,IAAI,GAAGa,QAAQ,CAAE7D,KAAF,EAAS8C,MAAM,CAAE,CAAF,CAAf,CAAR,CAA+BE,IAAtC;AACA,GAR8C,CAU/C;AACA;;;AACA,MAAKF,MAAM,CAAC3C,MAAP,KAAkB,CAAvB,EAA2B;AAC1B,QAAK0D,QAAQ,CAAE7D,KAAF,EAAS8C,MAAM,CAAE,CAAF,CAAf,CAAR,CAA+BE,IAA/B,KAAwC,gBAA7C,EAAgE;AAC/DA,MAAAA,IAAI,GAAGa,QAAQ,CAAE7D,KAAF,EAAS8C,MAAM,CAAE,CAAF,CAAf,CAAR,CAA+BE,IAAtC;AACA;AACD,GAhB8C,CAkB/C;;;AACA,UAASA,IAAT;AACC,SAAK,YAAL;AACC,aAAO,OAAP;;AACD,SAAK,YAAL;AACA,SAAK,gBAAL;AACC,aAAO,OAAP;;AACD,SAAK,cAAL;AACC,aAAO,SAAP;;AACD,SAAK,YAAL;AACA,SAAK,oBAAL;AACA,SAAK,kBAAL;AACC,aAAO,OAAP;;AACD,SAAK,YAAL;AACA,SAAK,oBAAL;AACA,SAAK,uBAAL;AACC,aAAO,OAAP;AAfF;;AAkBA,SAAO,IAAP;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASD,yBAAT,CAAoC/C,KAApC,EAA4C;AAClD,MAAM8C,MAAM,GAAG2B,SAAS,CAAEzE,KAAF,CAAxB,CADkD,CAGlD;AACA;;AACA,MAAMiK,8BAA8B,GACnCnH,MAAM,CAAC3C,MAAP,KAAkB,CAAlB,IACApB,wBAAwB,CAAE+D,MAAM,CAAE,CAAF,CAAR,CAFzB;;AAKA,MAAKmH,8BAAL,EAAsC;AACrC,WAAO,EAAP;AACA;;AAED,SAAOnH,MAAP;AACA;AAED;;;;;;;;;AAQA,OAAO,IAAMjB,oBAAoB,GAAGrD,cAAc,CACjD,UAAEwB,KAAF,EAAa;AACZ,MAAMsB,KAAK,GAAGF,YAAY,CAAEpB,KAAF,CAA1B;;AACA,MAAK,aAAasB,KAAlB,EAA0B;AACzB,WAAOA,KAAK,CAAC4I,OAAb;AACA;;AAED,MAAMpH,MAAM,GAAGC,yBAAyB,CAAE/C,KAAF,CAAxC;AACA,MAAMkK,OAAO,GAAGzL,SAAS,CAAEqE,MAAF,CAAzB,CAPY,CASZ;AACA;AACA;;AACA,MAAMqH,qBAAqB,GAC1BrH,MAAM,CAAC3C,MAAP,KAAkB,CAAlB,IACA2C,MAAM,CAAE,CAAF,CAAN,CAAYE,IAAZ,KAAqBlE,6BAA6B,EAFnD;;AAKA,MAAKqL,qBAAL,EAA6B;AAC5B,WAAOlL,OAAO,CAAEiL,OAAF,CAAd;AACA;;AAED,SAAOA,OAAP;AACA,CAvBgD,EAwBjD,UAAElK,KAAF;AAAA,SAAa,CACZA,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqBC,KAArB,CAA2B4I,OADf,EAEZlK,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAFT,CAAb;AAAA,CAxBiD,CAA3C;AA8BP;;;;;;;;;;AASA,OAAO,IAAMsH,kBAAkB,GAAG5L,cAAc,CAC/C,UAAEwB,KAAF,EAASkF,SAAT,EAA6C;AAAA,MAAzBR,YAAyB,uEAAV,IAAU;;AAC5C,MAAM2F,cAAc,GAAG,SAAjBA,cAAiB,CAAEC,IAAF,EAAQC,IAAR,EAAwC;AAAA,QAA1BC,aAA0B,uEAAV,IAAU;;AAC9D,QAAKvM,SAAS,CAAEqM,IAAF,CAAd,EAAyB;AACxB,aAAOA,IAAP;AACA;;AACD,QAAKtM,OAAO,CAAEsM,IAAF,CAAZ,EAAuB;AACtB,aAAOvM,QAAQ,CAAEuM,IAAF,EAAQC,IAAR,CAAf;AACA;;AACD,WAAOC,aAAP;AACA,GARD;;AAUA,MAAMC,SAAS,GAAG/L,YAAY,CAAEwG,SAAF,CAA9B;;AACA,MAAK,CAAEuF,SAAP,EAAmB;AAClB,WAAO,KAAP;AACA;;AAd2C,2BAgBdC,iBAAiB,CAAE1K,KAAF,CAhBH;AAAA,MAgBpC2K,iBAhBoC,sBAgBpCA,iBAhBoC;;AAkB5C,MAAMC,sBAAsB,GAAGP,cAAc,CAAEM,iBAAF,EAAqBzF,SAArB,EAAgC,IAAhC,CAA7C;;AACA,MAAK,CAAE0F,sBAAP,EAAgC;AAC/B,WAAO,KAAP;AACA;;AAED,MAAMC,QAAQ,GAAG,CAAC,CAAEzB,eAAe,CAAEpJ,KAAF,EAAS0E,YAAT,CAAnC;;AACA,MAAKmG,QAAL,EAAgB;AACf,WAAO,KAAP;AACA;;AAED,MAAMC,uBAAuB,GAAGvB,oBAAoB,CAAEvJ,KAAF,EAAS0E,YAAT,CAApD;AACA,MAAMqG,mBAAmB,GAAGlN,GAAG,CAAEiN,uBAAF,EAA2B,CAAE,eAAF,CAA3B,CAA/B;AACA,MAAME,qBAAqB,GAAGX,cAAc,CAAEU,mBAAF,EAAuB7F,SAAvB,CAA5C;AAEA,MAAM+F,wBAAwB,GAAGR,SAAS,CAACS,MAA3C;AACA,MAAMC,UAAU,GAAGrH,YAAY,CAAE9D,KAAF,EAAS0E,YAAT,CAA/B;AACA,MAAM0G,qBAAqB,GAAGf,cAAc,CAAEY,wBAAF,EAA4BE,UAA5B,CAA5C;;AAEA,MAAKH,qBAAqB,KAAK,IAA1B,IAAkCI,qBAAqB,KAAK,IAAjE,EAAwE;AACvE,WAAOJ,qBAAqB,IAAII,qBAAhC;AACA,GAFD,MAEO,IAAKJ,qBAAqB,KAAK,IAA/B,EAAsC;AAC5C,WAAOA,qBAAP;AACA,GAFM,MAEA,IAAKI,qBAAqB,KAAK,IAA/B,EAAsC;AAC5C,WAAOA,qBAAP;AACA;;AAED,SAAO,IAAP;AACA,CA9C8C,EA+C/C,UAAEpL,KAAF,EAASkF,SAAT,EAAoBR,YAApB;AAAA,SAAsC,CACrC1E,KAAK,CAACsJ,iBAAN,CAAyB5E,YAAzB,CADqC,EAErC1E,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAArB,CAA4BkB,UAA5B,CAAwCU,YAAxC,CAFqC,EAGrC1E,KAAK,CAACmJ,QAAN,CAAewB,iBAHsB,EAIrC3K,KAAK,CAACmJ,QAAN,CAAeE,YAJsB,CAAtC;AAAA,CA/C+C,CAAzC;AAuDP;;;;;;;;;;;AAUA,SAASgC,cAAT,CAAyBrL,KAAzB,EAAgCiB,EAAhC,EAAqC;AACpC,SAAOjB,KAAK,CAACsL,WAAN,CAAkBC,WAAlB,CAA+BtK,EAA/B,KAAuC,IAA9C;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA,OAAO,IAAMuK,gBAAgB,GAAGhN,cAAc,CAC7C,UAAEwB,KAAF,EAAkC;AAAA,MAAzB0E,YAAyB,uEAAV,IAAU;;AACjC,MAAM+G,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAEC,QAAF,EAAYvG,KAAZ,EAAmBwG,YAAnB,EAAqC;AAC7D,QAAKA,YAAL,EAAoB;AACnB,aAAOpM,qBAAP;AACA,KAFD,MAEO,IAAK4F,KAAK,GAAG,CAAb,EAAiB;AACvB,aAAO3F,uBAAP;AACA,KAFM,MAEA,IAAKkM,QAAQ,KAAK,QAAlB,EAA6B;AACnC,aAAOjM,oBAAP;AACA;;AACD,WAAOC,qBAAP;AACA,GATD;;AAWA,MAAMkM,iBAAiB,GAAG,SAApBA,iBAAoB,CAAEC,IAAF,EAAQ1G,KAAR,EAAmB;AAC5C,QAAK,CAAE0G,IAAP,EAAc;AACb,aAAO1G,KAAP;AACA,KAH2C,CAK5C;AACA;;;AACA,QAAM2G,QAAQ,GAAGC,IAAI,CAAC3I,GAAL,KAAayI,IAA9B;;AAEA,YAAS,IAAT;AACC,WAAKC,QAAQ,GAAGnM,qBAAhB;AACC,eAAOwF,KAAK,GAAG,CAAf;;AACD,WAAK2G,QAAQ,GAAGlM,oBAAhB;AACC,eAAOuF,KAAK,GAAG,CAAf;;AACD,WAAK2G,QAAQ,GAAGjM,qBAAhB;AACC,eAAOsF,KAAK,GAAG,CAAf;;AACD;AACC,eAAOA,KAAK,GAAG,CAAf;AARF;AAUA,GAnBD;;AAqBA,MAAM6G,sBAAsB,GAAG,SAAzBA,sBAAyB,CAAEvB,SAAF,EAAiB;AAC/C,QAAK,CAAE7L,eAAe,CAAE6L,SAAF,EAAa,UAAb,EAAyB,IAAzB,CAAtB,EAAwD;AACvD,aAAO,KAAP;AACA;;AAED,WAAOL,kBAAkB,CAAEpK,KAAF,EAASyK,SAAS,CAACzH,IAAnB,EAAyB0B,YAAzB,CAAzB;AACA,GAND;;AAQA,MAAMuH,0BAA0B,GAAG,SAA7BA,0BAA6B,CAAExB,SAAF,EAAiB;AACnD,QAAMxJ,EAAE,GAAGwJ,SAAS,CAACzH,IAArB;AAEA,QAAIkJ,UAAU,GAAG,KAAjB;;AACA,QAAK,CAAEtN,eAAe,CAAE6L,SAAS,CAACzH,IAAZ,EAAkB,UAAlB,EAA8B,IAA9B,CAAtB,EAA6D;AAC5DkJ,MAAAA,UAAU,GAAG3N,IAAI,CAAE6G,mBAAmB,CAAEpF,KAAF,EAAS8E,2BAA2B,CAAE9E,KAAF,CAApC,CAArB,EAAsE;AAAEgD,QAAAA,IAAI,EAAEyH,SAAS,CAACzH;AAAlB,OAAtE,CAAjB;AACA;;AAED,QAAM2I,YAAY,GAAG3N,OAAO,CAAEyM,SAAS,CAACS,MAAZ,CAA5B;;AARmD,eASvBG,cAAc,CAAErL,KAAF,EAASiB,EAAT,CAAd,IAA+B,EATR;AAAA,QAS3C4K,IAT2C,QAS3CA,IAT2C;AAAA,0BASrC1G,KATqC;AAAA,QASrCA,KATqC,2BAS7B,CAT6B;;AAWnD,WAAO;AACNlE,MAAAA,EAAE,EAAFA,EADM;AAEN+B,MAAAA,IAAI,EAAEyH,SAAS,CAACzH,IAFV;AAGNmJ,MAAAA,iBAAiB,EAAE,EAHb;AAINC,MAAAA,KAAK,EAAE3B,SAAS,CAAC2B,KAJX;AAKNC,MAAAA,IAAI,EAAE5B,SAAS,CAAC4B,IALV;AAMNX,MAAAA,QAAQ,EAAEjB,SAAS,CAACiB,QANd;AAONY,MAAAA,QAAQ,EAAE7B,SAAS,CAAC6B,QAPd;AAQNJ,MAAAA,UAAU,EAAVA,UARM;AASNK,MAAAA,OAAO,EAAEd,gBAAgB,CAAEhB,SAAS,CAACiB,QAAZ,EAAsBvG,KAAtB,EAA6BwG,YAA7B,CATnB;AAUNa,MAAAA,QAAQ,EAAEZ,iBAAiB,CAAEC,IAAF,EAAQ1G,KAAR,CAVrB;AAWNtG,MAAAA,iCAAiC,EAAEA,iCAAiC,CAAE4L,SAAS,CAACzH,IAAZ;AAX9D,KAAP;AAaA,GAxBD;;AA0BA,MAAMyJ,0BAA0B,GAAG,SAA7BA,0BAA6B,CAAEC,aAAF,EAAqB;AACvD,QAAK,CAAEtC,kBAAkB,CAAEpK,KAAF,EAAS,YAAT,EAAuB0E,YAAvB,CAAzB,EAAiE;AAChE,aAAO,KAAP;AACA;;AAED,QAAMiI,eAAe,GAAG9I,QAAQ,CAAE7D,KAAF,EAAS0M,aAAa,CAAChJ,QAAvB,CAAhC;;AACA,QAAK,CAAEiJ,eAAP,EAAyB;AACxB,aAAO,KAAP;AACA;;AAED,QAAMC,mBAAmB,GAAGlO,YAAY,CAAEiO,eAAe,CAAC3J,IAAlB,CAAxC;;AACA,QAAK,CAAE4J,mBAAP,EAA6B;AAC5B,aAAO,KAAP;AACA;;AAED,QAAK,CAAExC,kBAAkB,CAAEpK,KAAF,EAAS4M,mBAAmB,CAAC5J,IAA7B,EAAmC0B,YAAnC,CAAzB,EAA6E;AAC5E,aAAO,KAAP;AACA;;AAED,WAAO,IAAP;AACA,GApBD;;AAsBA,MAAMmI,8BAA8B,GAAG,SAAjCA,8BAAiC,CAAEH,aAAF,EAAqB;AAC3D,QAAMzL,EAAE,wBAAkByL,aAAa,CAACzL,EAAhC,CAAR;AAEA,QAAM0L,eAAe,GAAG9I,QAAQ,CAAE7D,KAAF,EAAS0M,aAAa,CAAChJ,QAAvB,CAAhC;AACA,QAAMkJ,mBAAmB,GAAGlO,YAAY,CAAEiO,eAAe,CAAC3J,IAAlB,CAAxC;;AAJ2D,gBAM/BqI,cAAc,CAAErL,KAAF,EAASiB,EAAT,CAAd,IAA+B,EANA;AAAA,QAMnD4K,IANmD,SAMnDA,IANmD;AAAA,4BAM7C1G,KAN6C;AAAA,QAM7CA,KAN6C,4BAMrC,CANqC;;AAO3D,QAAMoH,OAAO,GAAGd,gBAAgB,CAAE,UAAF,EAActG,KAAd,EAAqB,KAArB,CAAhC;AACA,QAAMqH,QAAQ,GAAGZ,iBAAiB,CAAEC,IAAF,EAAQ1G,KAAR,CAAlC;AAEA,WAAO;AACNlE,MAAAA,EAAE,EAAFA,EADM;AAEN+B,MAAAA,IAAI,EAAE,YAFA;AAGNmJ,MAAAA,iBAAiB,EAAE;AAAEW,QAAAA,GAAG,EAAEJ,aAAa,CAACzL;AAArB,OAHb;AAINmL,MAAAA,KAAK,EAAEM,aAAa,CAACN,KAJf;AAKNC,MAAAA,IAAI,EAAEO,mBAAmB,CAACP,IALpB;AAMNX,MAAAA,QAAQ,EAAE,UANJ;AAONY,MAAAA,QAAQ,EAAE,EAPJ;AAQNJ,MAAAA,UAAU,EAAE,KARN;AASNK,MAAAA,OAAO,EAAPA,OATM;AAUNC,MAAAA,QAAQ,EAARA;AAVM,KAAP;AAYA,GAtBD;;AAwBA,MAAMO,sBAAsB,GAAGpO,aAAa,GAC1CqO,MAD6B,CACrBhB,sBADqB,EAE7B7N,GAF6B,CAExB8N,0BAFwB,CAA/B;;AAIA,MAAMgB,0BAA0B,GAAGC,+BAA+B,CAAElN,KAAF,CAA/B,CACjCgN,MADiC,CACzBP,0BADyB,EAEjCtO,GAFiC,CAE5B0O,8BAF4B,CAAnC;;AAIA,SAAOzO,OAAO,oBACR2O,sBADQ,4BACmBE,0BADnB,IAEb,CAAE,SAAF,EAAa,UAAb,CAFa,EAGb,CAAE,MAAF,EAAU,MAAV,CAHa,CAAd;AAKA,CA/H4C,EAgI7C,UAAEjN,KAAF,EAAS0E,YAAT;AAAA,SAA2B,CAC1B1E,KAAK,CAACsJ,iBAAN,CAAyB5E,YAAzB,CAD0B,EAE1B1E,KAAK,CAACC,MAAN,CAAaoB,OAAb,CAAqByB,MAFK,EAG1B9C,KAAK,CAACsL,WAAN,CAAkBC,WAHQ,EAI1BvL,KAAK,CAACmJ,QAAN,CAAewB,iBAJW,EAK1B3K,KAAK,CAACmJ,QAAN,CAAeE,YALW,EAM1BrJ,KAAK,CAACmN,cAAN,CAAqBC,IANK,EAO1BzO,aAAa,EAPa,CAA3B;AAAA,CAhI6C,CAAvC;AA2IP;;;;;;;;;AAQA,OAAO,IAAM0O,8BAA8B,GAAG7O,cAAc,CAC3D,UAAEwB,KAAF,EAAS8M,GAAT,EAAkB;AACjB,MAAM/I,KAAK,GAAG/D,KAAK,CAACmN,cAAN,CAAqBC,IAArB,CAA2BN,GAA3B,CAAd;;AACA,MAAK,CAAE/I,KAAP,EAAe;AACd,WAAO,IAAP;AACA;;AAED,MAAMuJ,WAAW,GAAGC,KAAK,CAAEC,QAAQ,CAAEV,GAAF,CAAV,CAAzB;AAEA,2BACI/I,KADJ;AAEC9C,IAAAA,EAAE,EAAEqM,WAAW,GAAGR,GAAH,GAAS,CAACA,GAF1B;AAGCQ,IAAAA,WAAW,EAAXA;AAHD;AAKA,CAd0D,EAe3D,UAAEtN,KAAF,EAAS8M,GAAT;AAAA,SAAkB,CACjB9M,KAAK,CAACmN,cAAN,CAAqBC,IAArB,CAA2BN,GAA3B,CADiB,CAAlB;AAAA,CAf2D,CAArD;AAoBP;;;;;;;;;AAQA,OAAO,SAASW,mCAAT,CAA8CzN,KAA9C,EAAqD8M,GAArD,EAA2D;AACjE,SAAO9M,KAAK,CAACmN,cAAN,CAAqBO,QAArB,CAA+BZ,GAA/B,KAAwC,KAA/C;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASa,qCAAT,CAAgD3N,KAAhD,EAAuD8M,GAAvD,EAA6D;AACnE,SAAO,CAAC,CAAE9M,KAAK,CAACmN,cAAN,CAAqBS,UAArB,CAAiCd,GAAjC,CAAV;AACA;AAED;;;;;;;;AAOA,OAAO,SAASI,+BAAT,CAA0ClN,KAA1C,EAAkD;AACxD,SAAO7B,GAAG,CACT6B,KAAK,CAACmN,cAAN,CAAqBC,IADZ,EAET,UAAEjJ,KAAF,EAAS2I,GAAT;AAAA,WAAkBO,8BAA8B,CAAErN,KAAF,EAAS8M,GAAT,CAAhD;AAAA,GAFS,CAAV;AAIA;AAED;;;;;;;;;;AASA,OAAO,SAASe,mCAAT,CAA8C7N,KAA9C,EAAqD8N,aAArD,EAAqE;AAC3E,MAAMC,WAAW,GAAGpQ,IAAI,CAAEqC,KAAK,CAACgO,QAAR,EAAkB,UAAEC,KAAF;AAAA,WACzCA,KAAK,CAACC,WAAN,IACArQ,GAAG,CAAEoQ,KAAK,CAACE,MAAR,EAAgB,CAAE,UAAF,EAAc,IAAd,CAAhB,CAAH,KAA8CL,aAFL;AAAA,GAAlB,CAAxB;AAKA,SAAOC,WAAW,GAAGA,WAAW,CAACG,WAAf,GAA6B,IAA/C;AACA;AAED;;;;;;;;AAOA,OAAO,SAASE,gBAAT,CAA2BpO,KAA3B,EAAmC;AACzC,MAAK,CAAE4C,YAAY,CAAE5C,KAAF,CAAnB,EAA+B;AAC9B,WAAO,KAAP;AACA,GAHwC,CAKzC;AACA;;;AACA,MAAK,CAAEqC,sBAAsB,CAAErC,KAAF,CAA7B,EAAyC;AACxC,WAAO,KAAP;AACA,GATwC,CAWzC;AACA;;;AACA,MAAMqO,kBAAkB,GAAGR,mCAAmC,CAC7D7N,KAD6D,EAE7DX,0BAF6D,CAA9D,CAbyC,CAkBzC;AACA;;AACA,SAAO,CAAC,CAAEgP,kBAAH,IAAyB,CAAEhM,sBAAsB,CAAEgM,kBAAF,CAAxD;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,mBAAT,CAA8BtO,KAA9B,EAAsC;AAC5C,MAAMuO,iBAAiB,GAAG3M,sBAAsB,CAAE5B,KAAF,EAAS,oBAAT,CAAhD;AAEA,SAAOV,wBAAwB,CAACkP,IAAzB,CAA+BD,iBAA/B,CAAP;AACA;AAED;;;;;;;;AAOA,OAAO,SAASE,YAAT,CAAuBzO,KAAvB,EAA+B;AAAA,2BACA0O,iBAAiB,CAAE1O,KAAF,CADjB;AAAA,MAC7B2O,MAD6B,sBAC7BA,MAD6B;AAAA,MACrBC,QADqB,sBACrBA,QADqB;AAAA,MACXC,MADW,sBACXA,MADW;;AAGrC,MAAKP,mBAAmB,CAAEtO,KAAF,CAAxB,EAAoC;AACnC,WAAO2O,MAAM,GAAGC,QAAT,GAAoBC,MAA3B;AACA;;AAED,SAAOF,MAAP;AACA;AAED;;;;;;;;AAOA,OAAO,SAASD,iBAAT,CAA4B1O,KAA5B,EAAoC;AAC1C,MAAMuO,iBAAiB,GAAG3M,sBAAsB,CAAE5B,KAAF,EAAS,oBAAT,CAAhD;AACA,MAAM4O,QAAQ,GAAGhN,sBAAsB,CAAE5B,KAAF,EAAS,MAAT,CAAtB,IAA2C4B,sBAAsB,CAAE5B,KAAF,EAAS,gBAAT,CAAlF;;AAF0C,8BAIfuO,iBAAiB,CAACO,KAAlB,CAAyBxP,wBAAzB,CAJe;AAAA;AAAA,MAIlCqP,MAJkC;AAAA,MAI1BE,MAJ0B;;AAM1C,SAAO;AACNF,IAAAA,MAAM,EAANA,MADM;AAENC,IAAAA,QAAQ,EAARA,QAFM;AAGNC,IAAAA,MAAM,EAANA;AAHM,GAAP;AAKA;AAED;;;;;;;;;;AASA,OAAO,SAASlO,aAAT,CAAwBX,KAAxB,EAA+B+O,SAA/B,EAA2C;AAAA,MACzCf,QADyC,GAC5BhO,KAD4B,CACzCgO,QADyC,EAGjD;;AACA,MAAK,CAAEA,QAAP,EAAkB;AACjB,WAAO,KAAP;AACA;;AAED,SAAOA,QAAQ,CAACzP,IAAT,CAAe;AAAA,QAAI2P,WAAJ,SAAIA,WAAJ;AAAA,WACrBA,WAAW,IAAIa,SAAS,CAAEb,WAAF,CADH;AAAA,GAAf,CAAP;AAGA;AAED;;;;;;;;;AAQA,OAAO,SAAS3E,oBAAT,CAA+BvJ,KAA/B,EAAsC0D,QAAtC,EAAiD;AACvD,SAAO1D,KAAK,CAACsJ,iBAAN,CAAyB5F,QAAzB,CAAP;AACA;AAED;;;;;;;;AAOA,OAAO,SAASgH,iBAAT,CAA4B1K,KAA5B,EAAoC;AAC1C,SAAOA,KAAK,CAACmJ,QAAb;AACA;AAED;;;;;;;;;AAQA,OAAO,SAAS6F,gBAAT,CAA2BhP,KAA3B,EAAkCgD,IAAlC,EAAyC;AAC/C,MAAK,CAAEA,IAAP,EAAc;AACb,WAAOhD,KAAK,CAACiP,MAAb;AACA;;AAED,SAAOjP,KAAK,CAACiP,MAAN,CAAcjM,IAAd,CAAP;AACA;AAED;;;;;;;;AAOA,OAAO,SAASkM,YAAT,CAAuBlP,KAAvB,EAA+B;AACrC,SAAOA,KAAK,CAACmP,QAAN,CAAetE,QAAtB;AACA;AAED;;;;;;;;AAOA,OAAO,SAASuE,kBAAT,CAA6BpP,KAA7B,EAAqC;AAC3C,SAAOA,KAAK,CAACqP,cAAN,CAAqBlP,MAArB,GAA8B,CAArC;AACA;AAED;;;;;;;;AAOA,OAAO,SAASmP,kBAAT,CAA6BtP,KAA7B,EAAqC;AAC3C,SAAOA,KAAK,CAACmP,QAAN,CAAeI,UAAtB;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,eAAT,CAA0BxP,KAA1B,EAAkC;AACxC,SAAOA,KAAK,CAACmP,QAAN,CAAeM,IAAtB;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,iBAAT,CAA4B1P,KAA5B,EAAoC;AAC1C,SAAOA,KAAK,CAACmP,QAAN,CAAeQ,cAAtB;AACA;AAED;;;;;;;;AAOA,OAAO,SAASC,wBAAT,CAAmC5P,KAAnC,EAA2C;AACjD,SAAOlC,GAAG,CAAEyC,cAAc,CAAEP,KAAF,CAAhB,EAA2B,CAAE,QAAF,EAAY,2BAAZ,CAA3B,CAAV;AACA;AAED;;;;;;;;;AAQA,OAAO,SAAS6P,uBAAT,CAAkC7P,KAAlC,EAA0C;AAChD,MAAKA,KAAK,CAACsL,WAAN,CAAkB3J,cAAlB,CAAkC,yBAAlC,CAAL,EAAqE;AACpE,WAAO3B,KAAK,CAACsL,WAAN,CAAkBuE,uBAAzB;AACA;;AACD,SAAOzQ,oBAAoB,CAACyQ,uBAA5B;AACA,C,CAED;AACA;AACA;;AAEA,OAAO,SAASC,UAAT,GAAsB;AAC5B3Q,EAAAA,UAAU,CAAE,2CAAF,EAA+C;AACxD4Q,IAAAA,WAAW,EAAE,4CAD2C;AAExDC,IAAAA,MAAM,EAAE,WAFgD;AAGxDC,IAAAA,OAAO,EAAE;AAH+C,GAA/C,CAAV;AAMA,SAAO/Q,MAAM,CAAE,cAAF,CAAN,CAAyB4Q,UAAzB,EAAP;AACA;AAED,OAAO,SAASI,gBAAT,CAA2BlQ,KAA3B,EAAkC8M,GAAlC,EAAwC;AAC9C3N,EAAAA,UAAU,CAAE,yDAAF,EAA6D;AACtE4Q,IAAAA,WAAW,EAAE,yEADyD;AAEtEC,IAAAA,MAAM,EAAE,WAF8D;AAGtEC,IAAAA,OAAO,EAAE;AAH6D,GAA7D,CAAV;AAMA,SAAO5C,8BAA8B,CAAErN,KAAF,EAAS8M,GAAT,CAArC;AACA;AAED,OAAO,SAASqD,qBAAT,CAAgCnQ,KAAhC,EAAuC8M,GAAvC,EAA6C;AACnD3N,EAAAA,UAAU,CAAE,sDAAF,EAA0D;AACnE4Q,IAAAA,WAAW,EAAE,oEADsD;AAEnEC,IAAAA,MAAM,EAAE,WAF2D;AAGnEC,IAAAA,OAAO,EAAE,OAH0D;AAInEG,IAAAA,IAAI,EAAE;AAJ6D,GAA1D,CAAV;AAOA,SAAO3C,mCAAmC,CAAEzN,KAAF,EAAS8M,GAAT,CAA1C;AACA;AAED,OAAO,SAASuD,uBAAT,CAAkCrQ,KAAlC,EAAyC8M,GAAzC,EAA+C;AACrD3N,EAAAA,UAAU,CAAE,gEAAF,EAAoE;AAC7E4Q,IAAAA,WAAW,EAAE,4EADgE;AAE7EC,IAAAA,MAAM,EAAE,WAFqE;AAG7EC,IAAAA,OAAO,EAAE;AAHoE,GAApE,CAAV;AAMA,SAAOtC,qCAAqC,CAAE3N,KAAF,EAAS8M,GAAT,CAA5C;AACA;AAED,OAAO,SAASwD,iBAAT,CAA4BtQ,KAA5B,EAAoC;AAC1Cb,EAAAA,UAAU,CAAE,0DAAF,EAA8D;AACvE4Q,IAAAA,WAAW,EAAE,qEAD0D;AAEvEC,IAAAA,MAAM,EAAE,WAF+D;AAGvEC,IAAAA,OAAO,EAAE;AAH8D,GAA9D,CAAV;AAMA,SAAO/C,+BAA+B,CAAElN,KAAF,CAAtC;AACA","sourcesContent":["/**\n * External dependencies\n */\nimport {\n\tcastArray,\n\tflatMap,\n\tfind,\n\tfirst,\n\tget,\n\thas,\n\tincludes,\n\tisArray,\n\tisBoolean,\n\tlast,\n\tmap,\n\torderBy,\n\treduce,\n\tsize,\n\tsome,\n} from 'lodash';\nimport createSelector from 'rememo';\n\n/**\n * WordPress dependencies\n */\nimport {\n\tserialize,\n\tgetBlockType,\n\tgetBlockTypes,\n\thasBlockSupport,\n\thasChildBlocksWithInserterSupport,\n\tgetFreeformContentHandlerName,\n\tisUnmodifiedDefaultBlock,\n} from '@wordpress/blocks';\nimport { moment } from '@wordpress/date';\nimport { removep } from '@wordpress/autop';\nimport { select } from '@wordpress/data';\nimport deprecated from '@wordpress/deprecated';\n\n/**\n * Dependencies\n */\nimport { PREFERENCES_DEFAULTS } from './defaults';\n\n/***\n * Module constants\n */\nexport const POST_UPDATE_TRANSACTION_ID = 'post-update';\nconst PERMALINK_POSTNAME_REGEX = /%(?:postname|pagename)%/;\nexport const INSERTER_UTILITY_HIGH = 3;\nexport const INSERTER_UTILITY_MEDIUM = 2;\nexport const INSERTER_UTILITY_LOW = 1;\nexport const INSERTER_UTILITY_NONE = 0;\nconst MILLISECONDS_PER_HOUR = 3600 * 1000;\nconst MILLISECONDS_PER_DAY = 24 * 3600 * 1000;\nconst MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1000;\n\n/**\n * Shared reference to an empty array for cases where it is important to avoid\n * returning a new array reference on every invocation, as in a connected or\n * other pure component which performs `shouldComponentUpdate` check on props.\n * This should be used as a last resort, since the normalized data should be\n * maintained by the reducer result in state.\n *\n * @type {Array}\n */\nconst EMPTY_ARRAY = [];\n\n/**\n * Returns true if any past editor history snapshots exist, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether undo history exists.\n */\nexport function hasEditorUndo( state ) {\n\treturn state.editor.past.length > 0;\n}\n\n/**\n * Returns true if any future editor history snapshots exist, or false\n * otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether redo history exists.\n */\nexport function hasEditorRedo( state ) {\n\treturn state.editor.future.length > 0;\n}\n\n/**\n * Returns true if the currently edited post is yet to be saved, or false if\n * the post has been saved.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post is new.\n */\nexport function isEditedPostNew( state ) {\n\treturn getCurrentPost( state ).status === 'auto-draft';\n}\n\n/**\n * Returns true if there are unsaved values for the current edit session, or\n * false if the editing state matches the saved or new post.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether unsaved values exist.\n */\nexport function isEditedPostDirty( state ) {\n\treturn state.editor.isDirty || inSomeHistory( state, isEditedPostDirty );\n}\n\n/**\n * Returns true if there are no unsaved values for the current edit session and\n * if the currently edited post is new (has never been saved before).\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether new post and unsaved values exist.\n */\nexport function isCleanNewPost( state ) {\n\treturn ! isEditedPostDirty( state ) && isEditedPostNew( state );\n}\n\n/**\n * Returns the post currently being edited in its last known saved state, not\n * including unsaved edits. Returns an object containing relevant default post\n * values if the post has not yet been saved.\n *\n * @param {Object} state Global application state.\n *\n * @return {Object} Post object.\n */\nexport function getCurrentPost( state ) {\n\treturn state.currentPost;\n}\n\n/**\n * Returns the post type of the post currently being edited.\n *\n * @param {Object} state Global application state.\n *\n * @return {string} Post type.\n */\nexport function getCurrentPostType( state ) {\n\treturn state.currentPost.type;\n}\n\n/**\n * Returns the ID of the post currently being edited, or null if the post has\n * not yet been saved.\n *\n * @param {Object} state Global application state.\n *\n * @return {?number} ID of current post.\n */\nexport function getCurrentPostId( state ) {\n\treturn getCurrentPost( state ).id || null;\n}\n\n/**\n * Returns the number of revisions of the post currently being edited.\n *\n * @param {Object} state Global application state.\n *\n * @return {number} Number of revisions.\n */\nexport function getCurrentPostRevisionsCount( state ) {\n\treturn get( getCurrentPost( state ), [ '_links', 'version-history', 0, 'count' ], 0 );\n}\n\n/**\n * Returns the last revision ID of the post currently being edited,\n * or null if the post has no revisions.\n *\n * @param {Object} state Global application state.\n *\n * @return {?number} ID of the last revision.\n */\nexport function getCurrentPostLastRevisionId( state ) {\n\treturn get( getCurrentPost( state ), [ '_links', 'predecessor-version', 0, 'id' ], null );\n}\n\n/**\n * Returns any post values which have been changed in the editor but not yet\n * been saved.\n *\n * @param {Object} state Global application state.\n *\n * @return {Object} Object of key value pairs comprising unsaved edits.\n */\nexport function getPostEdits( state ) {\n\treturn state.editor.present.edits;\n}\n\n/**\n * Returns a new reference when edited values have changed. This is useful in\n * inferring where an edit has been made between states by comparison of the\n * return values using strict equality.\n *\n * @example\n *\n * ```\n * const hasEditOccurred = (\n *    getReferenceByDistinctEdits( beforeState ) !==\n *    getReferenceByDistinctEdits( afterState )\n * );\n * ```\n *\n * @param {Object} state Editor state.\n *\n * @return {*} A value whose reference will change only when an edit occurs.\n */\nexport const getReferenceByDistinctEdits = createSelector(\n\t() => [],\n\t( state ) => [ state.editor ],\n);\n\n/**\n * Returns an attribute value of the saved post.\n *\n * @param {Object} state         Global application state.\n * @param {string} attributeName Post attribute name.\n *\n * @return {*} Post attribute value.\n */\nexport function getCurrentPostAttribute( state, attributeName ) {\n\tconst post = getCurrentPost( state );\n\tif ( post.hasOwnProperty( attributeName ) ) {\n\t\treturn post[ attributeName ];\n\t}\n}\n\n/**\n * Returns a single attribute of the post being edited, preferring the unsaved\n * edit if one exists, but falling back to the attribute for the last known\n * saved state of the post.\n *\n * @param {Object} state         Global application state.\n * @param {string} attributeName Post attribute name.\n *\n * @return {*} Post attribute value.\n */\nexport function getEditedPostAttribute( state, attributeName ) {\n\tconst edits = getPostEdits( state );\n\n\t// Special cases\n\tswitch ( attributeName ) {\n\t\tcase 'content':\n\t\t\treturn getEditedPostContent( state );\n\t}\n\n\tif ( ! edits.hasOwnProperty( attributeName ) ) {\n\t\treturn getCurrentPostAttribute( state, attributeName );\n\t}\n\n\treturn edits[ attributeName ];\n}\n\n/**\n * Returns an attribute value of the current autosave revision for a post, or\n * null if there is no autosave for the post.\n *\n * @param {Object} state         Global application state.\n * @param {string} attributeName Autosave attribute name.\n *\n * @return {*} Autosave attribute value.\n */\nexport function getAutosaveAttribute( state, attributeName ) {\n\tif ( ! hasAutosave( state ) ) {\n\t\treturn null;\n\t}\n\n\tconst autosave = getAutosave( state );\n\tif ( autosave.hasOwnProperty( attributeName ) ) {\n\t\treturn autosave[ attributeName ];\n\t}\n}\n\n/**\n * Returns the current visibility of the post being edited, preferring the\n * unsaved value if different than the saved post. The return value is one of\n * \"private\", \"password\", or \"public\".\n *\n * @param {Object} state Global application state.\n *\n * @return {string} Post visibility.\n */\nexport function getEditedPostVisibility( state ) {\n\tconst status = getEditedPostAttribute( state, 'status' );\n\tconst password = getEditedPostAttribute( state, 'password' );\n\n\tif ( status === 'private' ) {\n\t\treturn 'private';\n\t} else if ( password ) {\n\t\treturn 'password';\n\t}\n\treturn 'public';\n}\n\n/**\n * Returns true if post is pending review.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether current post is pending review.\n */\nexport function isCurrentPostPending( state ) {\n\treturn getCurrentPost( state ).status === 'pending';\n}\n\n/**\n * Return true if the current post has already been published.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post has been published.\n */\nexport function isCurrentPostPublished( state ) {\n\tconst post = getCurrentPost( state );\n\n\treturn [ 'publish', 'private' ].indexOf( post.status ) !== -1 ||\n\t\t( post.status === 'future' && moment( post.date ).isBefore( moment() ) );\n}\n\n/**\n * Returns true if post is already scheduled.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether current post is scheduled to be posted.\n */\nexport function isCurrentPostScheduled( state ) {\n\treturn getCurrentPost( state ).status === 'future' && ! isCurrentPostPublished( state );\n}\n\n/**\n * Return true if the post being edited can be published.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post can been published.\n */\nexport function isEditedPostPublishable( state ) {\n\tconst post = getCurrentPost( state );\n\n\t// TODO: Post being publishable should be superset of condition of post\n\t// being saveable. Currently this restriction is imposed at UI.\n\t//\n\t//  See: <PostPublishButton /> (`isButtonEnabled` assigned by `isSaveable`)\n\n\treturn isEditedPostDirty( state ) || [ 'publish', 'private', 'future' ].indexOf( post.status ) === -1;\n}\n\n/**\n * Returns true if the post can be saved, or false otherwise. A post must\n * contain a title, an excerpt, or non-empty content to be valid for save.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post can be saved.\n */\nexport function isEditedPostSaveable( state ) {\n\tif ( isSavingPost( state ) ) {\n\t\treturn false;\n\t}\n\n\t// TODO: Post should not be saveable if not dirty. Cannot be added here at\n\t// this time since posts where meta boxes are present can be saved even if\n\t// the post is not dirty. Currently this restriction is imposed at UI, but\n\t// should be moved here.\n\t//\n\t//  See: `isEditedPostPublishable` (includes `isEditedPostDirty` condition)\n\t//  See: <PostSavedState /> (`forceIsDirty` prop)\n\t//  See: <PostPublishButton /> (`forceIsDirty` prop)\n\t//  See: https://github.com/WordPress/gutenberg/pull/4184\n\n\treturn (\n\t\t!! getEditedPostAttribute( state, 'title' ) ||\n\t\t!! getEditedPostAttribute( state, 'excerpt' ) ||\n\t\t! isEditedPostEmpty( state )\n\t);\n}\n\n/**\n * Returns true if the edited post has content. A post has content if it has at\n * least one saveable block or otherwise has a non-empty content property\n * assigned.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether post has content.\n */\nexport function isEditedPostEmpty( state ) {\n\tconst blocks = getBlocksForSerialization( state );\n\n\t// While the condition of truthy content string is sufficient to determine\n\t// emptiness, testing saveable blocks length is a trivial operation. Since\n\t// this function can be called frequently, optimize for the fast case as a\n\t// condition of the mere existence of blocks. Note that the value of edited\n\t// content is used in place of blocks, thus allowed to fall through.\n\tif ( blocks.length && ! ( 'content' in getPostEdits( state ) ) ) {\n\t\t// Pierce the abstraction of the serializer in knowing that blocks are\n\t\t// joined with with newlines such that even if every individual block\n\t\t// produces an empty save result, the serialized content is non-empty.\n\t\tif ( blocks.length > 1 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Freeform and unregistered blocks omit comment delimiters in their\n\t\t// output. The freeform block specifically may produce an empty string\n\t\t// to save. In the case of a single freeform block, fall through to the\n\t\t// full serialize. Otherwise, the single block is assumed non-empty by\n\t\t// virtue of its comment delimiters.\n\t\tif ( blocks[ 0 ].name !== getFreeformContentHandlerName() ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn ! getEditedPostContent( state );\n}\n\n/**\n * Returns true if the post can be autosaved, or false otherwise.\n *\n * @param  {Object}  state Global application state.\n *\n * @return {boolean} Whether the post can be autosaved.\n */\nexport function isEditedPostAutosaveable( state ) {\n\t// A post must contain a title, an excerpt, or non-empty content to be valid for autosaving.\n\tif ( ! isEditedPostSaveable( state ) ) {\n\t\treturn false;\n\t}\n\n\t// If we don't already have an autosave, the post is autosaveable.\n\tif ( ! hasAutosave( state ) ) {\n\t\treturn true;\n\t}\n\n\t// If the title, excerpt or content has changed, the post is autosaveable.\n\tconst autosave = getAutosave( state );\n\treturn [ 'title', 'excerpt', 'content' ].some( ( field ) => (\n\t\tautosave[ field ] !== getEditedPostAttribute( state, field )\n\t) );\n}\n\n/**\n * Returns the current autosave, or null if one is not set (i.e. if the post\n * has yet to be autosaved, or has been saved or published since the last\n * autosave).\n *\n * @param {Object} state Editor state.\n *\n * @return {?Object} Current autosave, if exists.\n */\nexport function getAutosave( state ) {\n\treturn state.autosave;\n}\n\n/**\n * Returns the true if there is an existing autosave, otherwise false.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether there is an existing autosave.\n */\nexport function hasAutosave( state ) {\n\treturn !! getAutosave( state );\n}\n\n/**\n * Return true if the post being edited is being scheduled. Preferring the\n * unsaved status values.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post has been published.\n */\nexport function isEditedPostBeingScheduled( state ) {\n\tconst date = moment( getEditedPostAttribute( state, 'date' ) );\n\t// Adding 1 minute as an error threshold between the server and the client dates.\n\tconst now = moment().add( 1, 'minute' );\n\n\treturn date.isAfter( now );\n}\n\n/**\n * Returns whether the current post should be considered to have a \"floating\"\n * date (i.e. that it would publish \"Immediately\" rather than at a set time).\n *\n * Unlike in the PHP backend, the REST API returns a full date string for posts\n * where the 0000-00-00T00:00:00 placeholder is present in the database. To\n * infer that a post is set to publish \"Immediately\" we check whether the date\n * and modified date are the same.\n *\n * @param  {Object}  state Editor state.\n *\n * @return {boolean} Whether the edited post has a floating date value.\n */\nexport function isEditedPostDateFloating( state ) {\n\tconst date = getEditedPostAttribute( state, 'date' );\n\tconst modified = getEditedPostAttribute( state, 'modified' );\n\tconst status = getEditedPostAttribute( state, 'status' );\n\tif ( status === 'draft' || status === 'auto-draft' ) {\n\t\treturn date === modified;\n\t}\n\treturn false;\n}\n\n/**\n * Returns a new reference when the inner blocks of a given block client ID\n * change. This is used exclusively as a memoized selector dependant, relying\n * on this selector's shared return value and recursively those of its inner\n * blocks defined as dependencies. This abuses mechanics of the selector\n * memoization to return from the original selector function only when\n * dependants change.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {*} A value whose reference will change only when inner blocks of\n *             the given block client ID change.\n */\nexport const getBlockDependantsCacheBust = createSelector(\n\t() => [],\n\t( state, clientId ) => map(\n\t\tgetBlockOrder( state, clientId ),\n\t\t( innerBlockClientId ) => getBlock( state, innerBlockClientId ),\n\t),\n);\n\n/**\n * Returns a block's name given its client ID, or null if no block exists with\n * the client ID.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {string} Block name.\n */\nexport function getBlockName( state, clientId ) {\n\tconst block = state.editor.present.blocks.byClientId[ clientId ];\n\treturn block ? block.name : null;\n}\n\n/**\n * Returns a block given its client ID. This is a parsed copy of the block,\n * containing its `blockName`, `clientId`, and current `attributes` state. This\n * is not the block's registration settings, which must be retrieved from the\n * blocks module registration store.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {Object} Parsed block object.\n */\nexport const getBlock = createSelector(\n\t( state, clientId ) => {\n\t\tconst block = state.editor.present.blocks.byClientId[ clientId ];\n\t\tif ( ! block ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet { attributes } = block;\n\n\t\t// Inject custom source attribute values.\n\t\t//\n\t\t// TODO: Create generic external sourcing pattern, not explicitly\n\t\t// targeting meta attributes.\n\t\tconst type = getBlockType( block.name );\n\t\tif ( type ) {\n\t\t\tattributes = reduce( type.attributes, ( result, value, key ) => {\n\t\t\t\tif ( value.source === 'meta' ) {\n\t\t\t\t\tif ( result === attributes ) {\n\t\t\t\t\t\tresult = { ...result };\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[ key ] = getPostMeta( state, value.meta );\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, attributes );\n\t\t}\n\n\t\treturn {\n\t\t\t...block,\n\t\t\tattributes,\n\t\t\tinnerBlocks: getBlocks( state, clientId ),\n\t\t};\n\t},\n\t( state, clientId ) => [\n\t\tstate.editor.present.blocks.byClientId[ clientId ],\n\t\tgetBlockDependantsCacheBust( state, clientId ),\n\t\tstate.editor.present.edits.meta,\n\t\tstate.currentPost.meta,\n\t]\n);\n\nfunction getPostMeta( state, key ) {\n\treturn has( state, [ 'editor', 'present', 'edits', 'meta', key ] ) ?\n\t\tget( state, [ 'editor', 'present', 'edits', 'meta', key ] ) :\n\t\tget( state, [ 'currentPost', 'meta', key ] );\n}\n\n/**\n * Returns all block objects for the current post being edited as an array in\n * the order they appear in the post.\n *\n * Note: It's important to memoize this selector to avoid return a new instance\n * on each call\n *\n * @param {Object}  state        Editor state.\n * @param {?String} rootClientId Optional root client ID of block list.\n *\n * @return {Object[]} Post blocks.\n */\nexport const getBlocks = createSelector(\n\t( state, rootClientId ) => {\n\t\treturn map(\n\t\t\tgetBlockOrder( state, rootClientId ),\n\t\t\t( clientId ) => getBlock( state, clientId )\n\t\t);\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks,\n\t]\n);\n\n/**\n * Returns an array containing the clientIds of all descendants\n * of the blocks given.\n *\n * @param {Object} state Global application state.\n * @param {Array} clientIds Array of blocks to inspect.\n *\n * @return {Array} ids of descendants.\n */\nexport const getClientIdsOfDescendants = ( state, clientIds ) => flatMap( clientIds, ( clientId ) => {\n\tconst descendants = getBlockOrder( state, clientId );\n\treturn [ ...descendants, ...getClientIdsOfDescendants( state, descendants ) ];\n} );\n\n/**\n * Returns an array containing the clientIds of the top-level blocks\n * and their descendants of any depth (for nested blocks).\n *\n * @param {Object} state Global application state.\n *\n * @return {Array} ids of top-level and descendant blocks.\n */\nexport const getClientIdsWithDescendants = createSelector(\n\t( state ) => {\n\t\tconst topLevelIds = getBlockOrder( state );\n\t\treturn [ ...topLevelIds, ...getClientIdsOfDescendants( state, topLevelIds ) ];\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t]\n);\n\n/**\n * Returns the total number of blocks, or the total number of blocks with a specific name in a post.\n * The number returned includes nested blocks.\n *\n * @param {Object}  state     Global application state.\n * @param {?String} blockName Optional block name, if specified only blocks of that type will be counted.\n *\n * @return {number} Number of blocks in the post, or number of blocks with name equal to blockName.\n */\nexport const getGlobalBlockCount = createSelector(\n\t( state, blockName ) => {\n\t\tif ( ! blockName ) {\n\t\t\treturn size( state.editor.present.blocks.byClientId );\n\t\t}\n\t\treturn reduce(\n\t\t\tstate.editor.present.blocks.byClientId,\n\t\t\t( count, block ) => block.name === blockName ? count + 1 : count,\n\t\t\t0\n\t\t);\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.byClientId,\n\t]\n);\n\n/**\n * Given an array of block client IDs, returns the corresponding array of block\n * objects.\n *\n * @param {Object}   state     Editor state.\n * @param {string[]} clientIds Client IDs for which blocks are to be returned.\n *\n * @return {WPBlock[]} Block objects.\n */\nexport const getBlocksByClientId = createSelector(\n\t( state, clientIds ) => map(\n\t\tcastArray( clientIds ),\n\t\t( clientId ) => getBlock( state, clientId )\n\t),\n\t( state ) => [\n\t\tstate.editor.present.edits.meta,\n\t\tstate.currentPost.meta,\n\t\tstate.editor.present.blocks,\n\t]\n);\n\n/**\n * Returns the number of blocks currently present in the post.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {number} Number of blocks in the post.\n */\nexport function getBlockCount( state, rootClientId ) {\n\treturn getBlockOrder( state, rootClientId ).length;\n}\n\n/**\n * Returns the current block selection start. This value may be null, and it\n * may represent either a singular block selection or multi-selection start.\n * A selection is singular if its start and end match.\n *\n * @param {Object} state Global application state.\n *\n * @return {?string} Client ID of block selection start.\n */\nexport function getBlockSelectionStart( state ) {\n\treturn state.blockSelection.start;\n}\n\n/**\n * Returns the current block selection end. This value may be null, and it\n * may represent either a singular block selection or multi-selection end.\n * A selection is singular if its start and end match.\n *\n * @param {Object} state Global application state.\n *\n * @return {?string} Client ID of block selection end.\n */\nexport function getBlockSelectionEnd( state ) {\n\treturn state.blockSelection.end;\n}\n\n/**\n * Returns the number of blocks currently selected in the post.\n *\n * @param {Object} state Global application state.\n *\n * @return {number} Number of blocks selected in the post.\n */\nexport function getSelectedBlockCount( state ) {\n\tconst multiSelectedBlockCount = getMultiSelectedBlockClientIds( state ).length;\n\n\tif ( multiSelectedBlockCount ) {\n\t\treturn multiSelectedBlockCount;\n\t}\n\n\treturn state.blockSelection.start ? 1 : 0;\n}\n\n/**\n * Returns true if there is a single selected block, or false otherwise.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether a single block is selected.\n */\nexport function hasSelectedBlock( state ) {\n\tconst { start, end } = state.blockSelection;\n\treturn !! start && start === end;\n}\n\n/**\n * Returns the currently selected block client ID, or null if there is no\n * selected block.\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Selected block client ID.\n */\nexport function getSelectedBlockClientId( state ) {\n\tconst { start, end } = state.blockSelection;\n\treturn start === end && start ? start : null;\n}\n\n/**\n * Returns the currently selected block, or null if there is no selected block.\n *\n * @param {Object} state Global application state.\n *\n * @return {?Object} Selected block.\n */\nexport function getSelectedBlock( state ) {\n\tconst clientId = getSelectedBlockClientId( state );\n\treturn clientId ? getBlock( state, clientId ) : null;\n}\n\n/**\n * Given a block client ID, returns the root block from which the block is\n * nested, an empty string for top-level blocks, or null if the block does not\n * exist.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block from which to find root client ID.\n *\n * @return {?string} Root client ID, if exists\n */\nexport const getBlockRootClientId = createSelector(\n\t( state, clientId ) => {\n\t\tconst { order } = state.editor.present.blocks;\n\n\t\tfor ( const rootClientId in order ) {\n\t\t\tif ( includes( order[ rootClientId ], clientId ) ) {\n\t\t\t\treturn rootClientId;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t]\n);\n\n/**\n * Given a block client ID, returns the root of the hierarchy from which the block is nested, return the block itself for root level blocks.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block from which to find root client ID.\n *\n * @return {string} Root client ID\n */\nexport const getBlockHierarchyRootClientId = createSelector(\n\t( state, clientId ) => {\n\t\tlet rootClientId = clientId;\n\t\tlet current = clientId;\n\t\twhile ( rootClientId ) {\n\t\t\tcurrent = rootClientId;\n\t\t\trootClientId = getBlockRootClientId( state, current );\n\t\t}\n\n\t\treturn current;\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t]\n);\n\n/**\n * Returns the client ID of the block adjacent one at the given reference\n * startClientId and modifier directionality. Defaults start startClientId to\n * the selected block, and direction as next block. Returns null if there is no\n * adjacent block.\n *\n * @param {Object}  state         Editor state.\n * @param {?string} startClientId Optional client ID of block from which to\n *                                search.\n * @param {?number} modifier      Directionality multiplier (1 next, -1\n *                                previous).\n *\n * @return {?string} Return the client ID of the block, or null if none exists.\n */\nexport function getAdjacentBlockClientId( state, startClientId, modifier = 1 ) {\n\t// Default to selected block.\n\tif ( startClientId === undefined ) {\n\t\tstartClientId = getSelectedBlockClientId( state );\n\t}\n\n\t// Try multi-selection starting at extent based on modifier.\n\tif ( startClientId === undefined ) {\n\t\tif ( modifier < 0 ) {\n\t\t\tstartClientId = getFirstMultiSelectedBlockClientId( state );\n\t\t} else {\n\t\t\tstartClientId = getLastMultiSelectedBlockClientId( state );\n\t\t}\n\t}\n\n\t// Validate working start client ID.\n\tif ( ! startClientId ) {\n\t\treturn null;\n\t}\n\n\t// Retrieve start block root client ID, being careful to allow the falsey\n\t// empty string top-level root by explicitly testing against null.\n\tconst rootClientId = getBlockRootClientId( state, startClientId );\n\tif ( rootClientId === null ) {\n\t\treturn null;\n\t}\n\n\tconst { order } = state.editor.present.blocks;\n\tconst orderSet = order[ rootClientId ];\n\tconst index = orderSet.indexOf( startClientId );\n\tconst nextIndex = ( index + ( 1 * modifier ) );\n\n\t// Block was first in set and we're attempting to get previous.\n\tif ( nextIndex < 0 ) {\n\t\treturn null;\n\t}\n\n\t// Block was last in set and we're attempting to get next.\n\tif ( nextIndex === orderSet.length ) {\n\t\treturn null;\n\t}\n\n\t// Assume incremented index is within the set.\n\treturn orderSet[ nextIndex ];\n}\n\n/**\n * Returns the previous block's client ID from the given reference start ID.\n * Defaults start to the selected block. Returns null if there is no previous\n * block.\n *\n * @param {Object}  state         Editor state.\n * @param {?string} startClientId Optional client ID of block from which to\n *                                search.\n *\n * @return {?string} Adjacent block's client ID, or null if none exists.\n */\nexport function getPreviousBlockClientId( state, startClientId ) {\n\treturn getAdjacentBlockClientId( state, startClientId, -1 );\n}\n\n/**\n * Returns the next block's client ID from the given reference start ID.\n * Defaults start to the selected block. Returns null if there is no next\n * block.\n *\n * @param {Object}  state         Editor state.\n * @param {?string} startClientId Optional client ID of block from which to\n *                                search.\n *\n * @return {?string} Adjacent block's client ID, or null if none exists.\n */\nexport function getNextBlockClientId( state, startClientId ) {\n\treturn getAdjacentBlockClientId( state, startClientId, 1 );\n}\n\n/**\n * Returns the initial caret position for the selected block.\n * This position is to used to position the caret properly when the selected block changes.\n *\n * @param {Object} state Global application state.\n *\n * @return {?Object} Selected block.\n */\nexport function getSelectedBlocksInitialCaretPosition( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start !== end || ! start ) {\n\t\treturn null;\n\t}\n\n\treturn state.blockSelection.initialPosition;\n}\n\n/**\n * Returns the current multi-selection set of block client IDs, or an empty\n * array if there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {Array} Multi-selected block client IDs.\n */\nexport const getMultiSelectedBlockClientIds = createSelector(\n\t( state ) => {\n\t\tconst { start, end } = state.blockSelection;\n\t\tif ( start === end ) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Retrieve root client ID to aid in retrieving relevant nested block\n\t\t// order, being careful to allow the falsey empty string top-level root\n\t\t// by explicitly testing against null.\n\t\tconst rootClientId = getBlockRootClientId( state, start );\n\t\tif ( rootClientId === null ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst blockOrder = getBlockOrder( state, rootClientId );\n\t\tconst startIndex = blockOrder.indexOf( start );\n\t\tconst endIndex = blockOrder.indexOf( end );\n\n\t\tif ( startIndex > endIndex ) {\n\t\t\treturn blockOrder.slice( endIndex, startIndex + 1 );\n\t\t}\n\n\t\treturn blockOrder.slice( startIndex, endIndex + 1 );\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t\tstate.blockSelection.start,\n\t\tstate.blockSelection.end,\n\t],\n);\n\n/**\n * Returns the current multi-selection set of blocks, or an empty array if\n * there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {Array} Multi-selected block objects.\n */\nexport const getMultiSelectedBlocks = createSelector(\n\t( state ) => {\n\t\tconst multiSelectedBlockClientIds = getMultiSelectedBlockClientIds( state );\n\t\tif ( ! multiSelectedBlockClientIds.length ) {\n\t\t\treturn EMPTY_ARRAY;\n\t\t}\n\n\t\treturn multiSelectedBlockClientIds.map( ( clientId ) => getBlock( state, clientId ) );\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t\tstate.blockSelection.start,\n\t\tstate.blockSelection.end,\n\t\tstate.editor.present.blocks.byClientId,\n\t\tstate.editor.present.edits.meta,\n\t\tstate.currentPost.meta,\n\t]\n);\n\n/**\n * Returns the client ID of the first block in the multi-selection set, or null\n * if there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} First block client ID in the multi-selection set.\n */\nexport function getFirstMultiSelectedBlockClientId( state ) {\n\treturn first( getMultiSelectedBlockClientIds( state ) ) || null;\n}\n\n/**\n * Returns the client ID of the last block in the multi-selection set, or null\n * if there is no multi-selection.\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Last block client ID in the multi-selection set.\n */\nexport function getLastMultiSelectedBlockClientId( state ) {\n\treturn last( getMultiSelectedBlockClientIds( state ) ) || null;\n}\n\n/**\n * Returns true if a multi-selection exists, and the block corresponding to the\n * specified client ID is the first block of the multi-selection set, or false\n * otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is first in multi-selection.\n */\nexport function isFirstMultiSelectedBlock( state, clientId ) {\n\treturn getFirstMultiSelectedBlockClientId( state ) === clientId;\n}\n\n/**\n * Returns true if the client ID occurs within the block multi-selection, or\n * false otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is in multi-selection set.\n */\nexport function isBlockMultiSelected( state, clientId ) {\n\treturn getMultiSelectedBlockClientIds( state ).indexOf( clientId ) !== -1;\n}\n\n/**\n * Returns true if an ancestor of the block is multi-selected, or false\n * otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether an ancestor of the block is in multi-selection\n *                   set.\n */\nexport const isAncestorMultiSelected = createSelector(\n\t( state, clientId ) => {\n\t\tlet ancestorClientId = clientId;\n\t\tlet isMultiSelected = false;\n\t\twhile ( ancestorClientId && ! isMultiSelected ) {\n\t\t\tancestorClientId = getBlockRootClientId( state, ancestorClientId );\n\t\t\tisMultiSelected = isBlockMultiSelected( state, ancestorClientId );\n\t\t}\n\t\treturn isMultiSelected;\n\t},\n\t( state ) => [\n\t\tstate.editor.present.blocks.order,\n\t\tstate.blockSelection.start,\n\t\tstate.blockSelection.end,\n\t],\n);\n/**\n * Returns the client ID of the block which begins the multi-selection set, or\n * null if there is no multi-selection.\n *\n * This is not necessarily the first client ID in the selection.\n *\n * @see getFirstMultiSelectedBlockClientId\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Client ID of block beginning multi-selection.\n */\nexport function getMultiSelectedBlocksStartClientId( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start === end ) {\n\t\treturn null;\n\t}\n\treturn start || null;\n}\n\n/**\n * Returns the client ID of the block which ends the multi-selection set, or\n * null if there is no multi-selection.\n *\n * This is not necessarily the last client ID in the selection.\n *\n * @see getLastMultiSelectedBlockClientId\n *\n * @param {Object} state Editor state.\n *\n * @return {?string} Client ID of block ending multi-selection.\n */\nexport function getMultiSelectedBlocksEndClientId( state ) {\n\tconst { start, end } = state.blockSelection;\n\tif ( start === end ) {\n\t\treturn null;\n\t}\n\treturn end || null;\n}\n\n/**\n * Returns an array containing all block client IDs in the editor in the order\n * they appear. Optionally accepts a root client ID of the block list for which\n * the order should be returned, defaulting to the top-level block order.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {Array} Ordered client IDs of editor blocks.\n */\nexport function getBlockOrder( state, rootClientId ) {\n\treturn state.editor.present.blocks.order[ rootClientId || '' ] || EMPTY_ARRAY;\n}\n\n/**\n * Returns the index at which the block corresponding to the specified client\n * ID occurs within the block order, or `-1` if the block does not exist.\n *\n * @param {Object}  state        Editor state.\n * @param {string}  clientId     Block client ID.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {number} Index at which block exists in order.\n */\nexport function getBlockIndex( state, clientId, rootClientId ) {\n\treturn getBlockOrder( state, rootClientId ).indexOf( clientId );\n}\n\n/**\n * Returns true if the block corresponding to the specified client ID is\n * currently selected and no multi-selection exists, or false otherwise.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is selected and multi-selection exists.\n */\nexport function isBlockSelected( state, clientId ) {\n\tconst { start, end } = state.blockSelection;\n\n\tif ( start !== end ) {\n\t\treturn false;\n\t}\n\n\treturn start === clientId;\n}\n\n/**\n * Returns true if one of the block's inner blocks is selected.\n *\n * @param {Object}  state    Editor state.\n * @param {string}  clientId Block client ID.\n * @param {boolean} deep     Perform a deep check.\n *\n * @return {boolean} Whether the block as an inner block selected\n */\nexport function hasSelectedInnerBlock( state, clientId, deep = false ) {\n\treturn some(\n\t\tgetBlockOrder( state, clientId ),\n\t\t( innerClientId ) => (\n\t\t\tisBlockSelected( state, innerClientId ) ||\n\t\t\tisBlockMultiSelected( state, innerClientId ) ||\n\t\t\t( deep && hasSelectedInnerBlock( state, innerClientId, deep ) )\n\t\t)\n\t);\n}\n\n/**\n * Returns true if the block corresponding to the specified client ID is\n * currently selected but isn't the last of the selected blocks. Here \"last\"\n * refers to the block sequence in the document, _not_ the sequence of\n * multi-selection, which is why `state.blockSelection.end` isn't used.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {boolean} Whether block is selected and not the last in the\n *                   selection.\n */\nexport function isBlockWithinSelection( state, clientId ) {\n\tif ( ! clientId ) {\n\t\treturn false;\n\t}\n\n\tconst clientIds = getMultiSelectedBlockClientIds( state );\n\tconst index = clientIds.indexOf( clientId );\n\treturn index > -1 && index < clientIds.length - 1;\n}\n\n/**\n * Returns true if a multi-selection has been made, or false otherwise.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether multi-selection has been made.\n */\nexport function hasMultiSelection( state ) {\n\tconst { start, end } = state.blockSelection;\n\treturn start !== end;\n}\n\n/**\n * Whether in the process of multi-selecting or not. This flag is only true\n * while the multi-selection is being selected (by mouse move), and is false\n * once the multi-selection has been settled.\n *\n * @see hasMultiSelection\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} True if multi-selecting, false if not.\n */\nexport function isMultiSelecting( state ) {\n\treturn state.blockSelection.isMultiSelecting;\n}\n\n/**\n * Whether is selection disable or not.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} True if multi is disable, false if not.\n */\nexport function isSelectionEnabled( state ) {\n\treturn state.blockSelection.isEnabled;\n}\n\n/**\n * Returns the block's editing mode, defaulting to \"visual\" if not explicitly\n * assigned.\n *\n * @param {Object} state    Editor state.\n * @param {string} clientId Block client ID.\n *\n * @return {Object} Block editing mode.\n */\nexport function getBlockMode( state, clientId ) {\n\treturn state.blocksMode[ clientId ] || 'visual';\n}\n\n/**\n * Returns true if the user is typing, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether user is typing.\n */\nexport function isTyping( state ) {\n\treturn state.isTyping;\n}\n\n/**\n * Returns true if the caret is within formatted text, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the caret is within formatted text.\n */\nexport function isCaretWithinFormattedText( state ) {\n\treturn state.isCaretWithinFormattedText;\n}\n\n/**\n * Returns the insertion point, the index at which the new inserted block would\n * be placed. Defaults to the last index.\n *\n * @param {Object} state Editor state.\n *\n * @return {Object} Insertion point object with `rootClientId`, `index`.\n */\nexport function getBlockInsertionPoint( state ) {\n\tlet rootClientId, index;\n\n\tconst { insertionPoint, blockSelection } = state;\n\tif ( insertionPoint !== null ) {\n\t\treturn insertionPoint;\n\t}\n\n\tconst { end } = blockSelection;\n\tif ( end ) {\n\t\trootClientId = getBlockRootClientId( state, end ) || undefined;\n\t\tindex = getBlockIndex( state, end, rootClientId ) + 1;\n\t} else {\n\t\tindex = getBlockOrder( state ).length;\n\t}\n\n\treturn { rootClientId, index };\n}\n\n/**\n * Returns true if we should show the block insertion point.\n *\n * @param {Object} state Global application state.\n *\n * @return {?boolean} Whether the insertion point is visible or not.\n */\nexport function isBlockInsertionPointVisible( state ) {\n\treturn state.insertionPoint !== null;\n}\n\n/**\n * Returns whether the blocks matches the template or not.\n *\n * @param {boolean} state\n * @return {?boolean} Whether the template is valid or not.\n */\nexport function isValidTemplate( state ) {\n\treturn state.template.isValid;\n}\n\n/**\n * Returns the defined block template\n *\n * @param {boolean} state\n * @return {?Array}        Block Template\n */\nexport function getTemplate( state ) {\n\treturn state.settings.template;\n}\n\n/**\n * Returns the defined block template lock. Optionally accepts a root block\n * client ID as context, otherwise defaulting to the global context.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional block root client ID.\n *\n * @return {?string} Block Template Lock\n */\nexport function getTemplateLock( state, rootClientId ) {\n\tif ( ! rootClientId ) {\n\t\treturn state.settings.templateLock;\n\t}\n\n\tconst blockListSettings = getBlockListSettings( state, rootClientId );\n\tif ( ! blockListSettings ) {\n\t\treturn null;\n\t}\n\n\treturn blockListSettings.templateLock;\n}\n\n/**\n * Returns true if the post is currently being saved, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether post is being saved.\n */\nexport function isSavingPost( state ) {\n\treturn state.saving.requesting;\n}\n\n/**\n * Returns true if a previous post save was attempted successfully, or false\n * otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post was saved successfully.\n */\nexport function didPostSaveRequestSucceed( state ) {\n\treturn state.saving.successful;\n}\n\n/**\n * Returns true if a previous post save was attempted but failed, or false\n * otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post save failed.\n */\nexport function didPostSaveRequestFail( state ) {\n\treturn !! state.saving.error;\n}\n\n/**\n * Returns true if the post is autosaving, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the post is autosaving.\n */\nexport function isAutosavingPost( state ) {\n\treturn isSavingPost( state ) && state.saving.isAutosave;\n}\n\n/**\n * Returns a suggested post format for the current post, inferred only if there\n * is a single block within the post and it is of a type known to match a\n * default post format. Returns null if the format cannot be determined.\n *\n * @param {Object} state Global application state.\n *\n * @return {?string} Suggested post format.\n */\nexport function getSuggestedPostFormat( state ) {\n\tconst blocks = getBlockOrder( state );\n\n\tlet name;\n\t// If there is only one block in the content of the post grab its name\n\t// so we can derive a suitable post format from it.\n\tif ( blocks.length === 1 ) {\n\t\tname = getBlock( state, blocks[ 0 ] ).name;\n\t}\n\n\t// If there are two blocks in the content and the last one is a text blocks\n\t// grab the name of the first one to also suggest a post format from it.\n\tif ( blocks.length === 2 ) {\n\t\tif ( getBlock( state, blocks[ 1 ] ).name === 'core/paragraph' ) {\n\t\t\tname = getBlock( state, blocks[ 0 ] ).name;\n\t\t}\n\t}\n\n\t// We only convert to default post formats in core.\n\tswitch ( name ) {\n\t\tcase 'core/image':\n\t\t\treturn 'image';\n\t\tcase 'core/quote':\n\t\tcase 'core/pullquote':\n\t\t\treturn 'quote';\n\t\tcase 'core/gallery':\n\t\t\treturn 'gallery';\n\t\tcase 'core/video':\n\t\tcase 'core-embed/youtube':\n\t\tcase 'core-embed/vimeo':\n\t\t\treturn 'video';\n\t\tcase 'core/audio':\n\t\tcase 'core-embed/spotify':\n\t\tcase 'core-embed/soundcloud':\n\t\t\treturn 'audio';\n\t}\n\n\treturn null;\n}\n\n/**\n * Returns a set of blocks which are to be used in consideration of the post's\n * generated save content.\n *\n * @param {Object} state Editor state.\n *\n * @return {WPBlock[]} Filtered set of blocks for save.\n */\nexport function getBlocksForSerialization( state ) {\n\tconst blocks = getBlocks( state );\n\n\t// A single unmodified default block is assumed to be equivalent to an\n\t// empty post.\n\tconst isSingleUnmodifiedDefaultBlock = (\n\t\tblocks.length === 1 &&\n\t\tisUnmodifiedDefaultBlock( blocks[ 0 ] )\n\t);\n\n\tif ( isSingleUnmodifiedDefaultBlock ) {\n\t\treturn [];\n\t}\n\n\treturn blocks;\n}\n\n/**\n * Returns the content of the post being edited, preferring raw string edit\n * before falling back to serialization of block state.\n *\n * @param {Object} state Global application state.\n *\n * @return {string} Post content.\n */\nexport const getEditedPostContent = createSelector(\n\t( state ) => {\n\t\tconst edits = getPostEdits( state );\n\t\tif ( 'content' in edits ) {\n\t\t\treturn edits.content;\n\t\t}\n\n\t\tconst blocks = getBlocksForSerialization( state );\n\t\tconst content = serialize( blocks );\n\n\t\t// For compatibility purposes, treat a post consisting of a single\n\t\t// freeform block as legacy content and downgrade to a pre-block-editor\n\t\t// removep'd content format.\n\t\tconst isSingleFreeformBlock = (\n\t\t\tblocks.length === 1 &&\n\t\t\tblocks[ 0 ].name === getFreeformContentHandlerName()\n\t\t);\n\n\t\tif ( isSingleFreeformBlock ) {\n\t\t\treturn removep( content );\n\t\t}\n\n\t\treturn content;\n\t},\n\t( state ) => [\n\t\tstate.editor.present.edits.content,\n\t\tstate.editor.present.blocks,\n\t],\n);\n\n/**\n * Determines if the given block type is allowed to be inserted into the block list.\n *\n * @param {Object}  state        Editor state.\n * @param {string}  blockName    The name of the block type, e.g.' core/paragraph'.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {boolean} Whether the given block type is allowed to be inserted.\n */\nexport const canInsertBlockType = createSelector(\n\t( state, blockName, rootClientId = null ) => {\n\t\tconst checkAllowList = ( list, item, defaultResult = null ) => {\n\t\t\tif ( isBoolean( list ) ) {\n\t\t\t\treturn list;\n\t\t\t}\n\t\t\tif ( isArray( list ) ) {\n\t\t\t\treturn includes( list, item );\n\t\t\t}\n\t\t\treturn defaultResult;\n\t\t};\n\n\t\tconst blockType = getBlockType( blockName );\n\t\tif ( ! blockType ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { allowedBlockTypes } = getEditorSettings( state );\n\n\t\tconst isBlockAllowedInEditor = checkAllowList( allowedBlockTypes, blockName, true );\n\t\tif ( ! isBlockAllowedInEditor ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst isLocked = !! getTemplateLock( state, rootClientId );\n\t\tif ( isLocked ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst parentBlockListSettings = getBlockListSettings( state, rootClientId );\n\t\tconst parentAllowedBlocks = get( parentBlockListSettings, [ 'allowedBlocks' ] );\n\t\tconst hasParentAllowedBlock = checkAllowList( parentAllowedBlocks, blockName );\n\n\t\tconst blockAllowedParentBlocks = blockType.parent;\n\t\tconst parentName = getBlockName( state, rootClientId );\n\t\tconst hasBlockAllowedParent = checkAllowList( blockAllowedParentBlocks, parentName );\n\n\t\tif ( hasParentAllowedBlock !== null && hasBlockAllowedParent !== null ) {\n\t\t\treturn hasParentAllowedBlock || hasBlockAllowedParent;\n\t\t} else if ( hasParentAllowedBlock !== null ) {\n\t\t\treturn hasParentAllowedBlock;\n\t\t} else if ( hasBlockAllowedParent !== null ) {\n\t\t\treturn hasBlockAllowedParent;\n\t\t}\n\n\t\treturn true;\n\t},\n\t( state, blockName, rootClientId ) => [\n\t\tstate.blockListSettings[ rootClientId ],\n\t\tstate.editor.present.blocks.byClientId[ rootClientId ],\n\t\tstate.settings.allowedBlockTypes,\n\t\tstate.settings.templateLock,\n\t],\n);\n\n/**\n * Returns information about how recently and frequently a block has been inserted.\n *\n * @param {Object} state Global application state.\n * @param {string} id    A string which identifies the insert, e.g. 'core/block/12'\n *\n * @return {?{ time: number, count: number }} An object containing `time` which is when the last\n *                                            insert occured as a UNIX epoch, and `count` which is\n *                                            the number of inserts that have occurred.\n */\nfunction getInsertUsage( state, id ) {\n\treturn state.preferences.insertUsage[ id ] || null;\n}\n\n/**\n * Determines the items that appear in the inserter. Includes both static\n * items (e.g. a regular block type) and dynamic items (e.g. a reusable block).\n *\n * Each item object contains what's necessary to display a button in the\n * inserter and handle its selection.\n *\n * The 'utility' property indicates how useful we think an item will be to the\n * user. There are 4 levels of utility:\n *\n * 1. Blocks that are contextually useful (utility = 3)\n * 2. Blocks that have been previously inserted (utility = 2)\n * 3. Blocks that are in the common category (utility = 1)\n * 4. All other blocks (utility = 0)\n *\n * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)\n * that combines block usage frequenty and recency.\n *\n * Items are returned ordered descendingly by their 'utility' and 'frecency'.\n *\n * @param {Object}  state        Editor state.\n * @param {?string} rootClientId Optional root client ID of block list.\n *\n * @return {Editor.InserterItem[]} Items that appear in inserter.\n *\n * @typedef {Object} Editor.InserterItem\n * @property {string}   id                Unique identifier for the item.\n * @property {string}   name              The type of block to create.\n * @property {Object}   initialAttributes Attributes to pass to the newly created block.\n * @property {string}   title             Title of the item, as it appears in the inserter.\n * @property {string}   icon              Dashicon for the item, as it appears in the inserter.\n * @property {string}   category          Block category that the item is associated with.\n * @property {string[]} keywords          Keywords that can be searched to find this item.\n * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting\n *                                        this item.\n * @property {number}   utility           How useful we think this item is, between 0 and 3.\n * @property {number}   frecency          Hueristic that combines frequency and recency.\n */\nexport const getInserterItems = createSelector(\n\t( state, rootClientId = null ) => {\n\t\tconst calculateUtility = ( category, count, isContextual ) => {\n\t\t\tif ( isContextual ) {\n\t\t\t\treturn INSERTER_UTILITY_HIGH;\n\t\t\t} else if ( count > 0 ) {\n\t\t\t\treturn INSERTER_UTILITY_MEDIUM;\n\t\t\t} else if ( category === 'common' ) {\n\t\t\t\treturn INSERTER_UTILITY_LOW;\n\t\t\t}\n\t\t\treturn INSERTER_UTILITY_NONE;\n\t\t};\n\n\t\tconst calculateFrecency = ( time, count ) => {\n\t\t\tif ( ! time ) {\n\t\t\t\treturn count;\n\t\t\t}\n\n\t\t\t// The selector is cached, which means Date.now() is the last time that the\n\t\t\t// relevant state changed. This suits our needs.\n\t\t\tconst duration = Date.now() - time;\n\n\t\t\tswitch ( true ) {\n\t\t\t\tcase duration < MILLISECONDS_PER_HOUR:\n\t\t\t\t\treturn count * 4;\n\t\t\t\tcase duration < MILLISECONDS_PER_DAY:\n\t\t\t\t\treturn count * 2;\n\t\t\t\tcase duration < MILLISECONDS_PER_WEEK:\n\t\t\t\t\treturn count / 2;\n\t\t\t\tdefault:\n\t\t\t\t\treturn count / 4;\n\t\t\t}\n\t\t};\n\n\t\tconst shouldIncludeBlockType = ( blockType ) => {\n\t\t\tif ( ! hasBlockSupport( blockType, 'inserter', true ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn canInsertBlockType( state, blockType.name, rootClientId );\n\t\t};\n\n\t\tconst buildBlockTypeInserterItem = ( blockType ) => {\n\t\t\tconst id = blockType.name;\n\n\t\t\tlet isDisabled = false;\n\t\t\tif ( ! hasBlockSupport( blockType.name, 'multiple', true ) ) {\n\t\t\t\tisDisabled = some( getBlocksByClientId( state, getClientIdsWithDescendants( state ) ), { name: blockType.name } );\n\t\t\t}\n\n\t\t\tconst isContextual = isArray( blockType.parent );\n\t\t\tconst { time, count = 0 } = getInsertUsage( state, id ) || {};\n\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tname: blockType.name,\n\t\t\t\tinitialAttributes: {},\n\t\t\t\ttitle: blockType.title,\n\t\t\t\ticon: blockType.icon,\n\t\t\t\tcategory: blockType.category,\n\t\t\t\tkeywords: blockType.keywords,\n\t\t\t\tisDisabled,\n\t\t\t\tutility: calculateUtility( blockType.category, count, isContextual ),\n\t\t\t\tfrecency: calculateFrecency( time, count ),\n\t\t\t\thasChildBlocksWithInserterSupport: hasChildBlocksWithInserterSupport( blockType.name ),\n\t\t\t};\n\t\t};\n\n\t\tconst shouldIncludeReusableBlock = ( reusableBlock ) => {\n\t\t\tif ( ! canInsertBlockType( state, 'core/block', rootClientId ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst referencedBlock = getBlock( state, reusableBlock.clientId );\n\t\t\tif ( ! referencedBlock ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst referencedBlockType = getBlockType( referencedBlock.name );\n\t\t\tif ( ! referencedBlockType ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ( ! canInsertBlockType( state, referencedBlockType.name, rootClientId ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\n\t\tconst buildReusableBlockInserterItem = ( reusableBlock ) => {\n\t\t\tconst id = `core/block/${ reusableBlock.id }`;\n\n\t\t\tconst referencedBlock = getBlock( state, reusableBlock.clientId );\n\t\t\tconst referencedBlockType = getBlockType( referencedBlock.name );\n\n\t\t\tconst { time, count = 0 } = getInsertUsage( state, id ) || {};\n\t\t\tconst utility = calculateUtility( 'reusable', count, false );\n\t\t\tconst frecency = calculateFrecency( time, count );\n\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tname: 'core/block',\n\t\t\t\tinitialAttributes: { ref: reusableBlock.id },\n\t\t\t\ttitle: reusableBlock.title,\n\t\t\t\ticon: referencedBlockType.icon,\n\t\t\t\tcategory: 'reusable',\n\t\t\t\tkeywords: [],\n\t\t\t\tisDisabled: false,\n\t\t\t\tutility,\n\t\t\t\tfrecency,\n\t\t\t};\n\t\t};\n\n\t\tconst blockTypeInserterItems = getBlockTypes()\n\t\t\t.filter( shouldIncludeBlockType )\n\t\t\t.map( buildBlockTypeInserterItem );\n\n\t\tconst reusableBlockInserterItems = __experimentalGetReusableBlocks( state )\n\t\t\t.filter( shouldIncludeReusableBlock )\n\t\t\t.map( buildReusableBlockInserterItem );\n\n\t\treturn orderBy(\n\t\t\t[ ...blockTypeInserterItems, ...reusableBlockInserterItems ],\n\t\t\t[ 'utility', 'frecency' ],\n\t\t\t[ 'desc', 'desc' ]\n\t\t);\n\t},\n\t( state, rootClientId ) => [\n\t\tstate.blockListSettings[ rootClientId ],\n\t\tstate.editor.present.blocks,\n\t\tstate.preferences.insertUsage,\n\t\tstate.settings.allowedBlockTypes,\n\t\tstate.settings.templateLock,\n\t\tstate.reusableBlocks.data,\n\t\tgetBlockTypes(),\n\t],\n);\n\n/**\n * Returns the reusable block with the given ID.\n *\n * @param {Object}        state Global application state.\n * @param {number|string} ref   The reusable block's ID.\n *\n * @return {Object} The reusable block, or null if none exists.\n */\nexport const __experimentalGetReusableBlock = createSelector(\n\t( state, ref ) => {\n\t\tconst block = state.reusableBlocks.data[ ref ];\n\t\tif ( ! block ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst isTemporary = isNaN( parseInt( ref ) );\n\n\t\treturn {\n\t\t\t...block,\n\t\t\tid: isTemporary ? ref : +ref,\n\t\t\tisTemporary,\n\t\t};\n\t},\n\t( state, ref ) => [\n\t\tstate.reusableBlocks.data[ ref ],\n\t],\n);\n\n/**\n * Returns whether or not the reusable block with the given ID is being saved.\n *\n * @param {Object} state Global application state.\n * @param {string} ref   The reusable block's ID.\n *\n * @return {boolean} Whether or not the reusable block is being saved.\n */\nexport function __experimentalIsSavingReusableBlock( state, ref ) {\n\treturn state.reusableBlocks.isSaving[ ref ] || false;\n}\n\n/**\n * Returns true if the reusable block with the given ID is being fetched, or\n * false otherwise.\n *\n * @param {Object} state Global application state.\n * @param {string} ref   The reusable block's ID.\n *\n * @return {boolean} Whether the reusable block is being fetched.\n */\nexport function __experimentalIsFetchingReusableBlock( state, ref ) {\n\treturn !! state.reusableBlocks.isFetching[ ref ];\n}\n\n/**\n * Returns an array of all reusable blocks.\n *\n * @param {Object} state Global application state.\n *\n * @return {Array} An array of all reusable blocks.\n */\nexport function __experimentalGetReusableBlocks( state ) {\n\treturn map(\n\t\tstate.reusableBlocks.data,\n\t\t( value, ref ) => __experimentalGetReusableBlock( state, ref )\n\t);\n}\n\n/**\n * Returns state object prior to a specified optimist transaction ID, or `null`\n * if the transaction corresponding to the given ID cannot be found.\n *\n * @param {Object} state         Current global application state.\n * @param {Object} transactionId Optimist transaction ID.\n *\n * @return {Object} Global application state prior to transaction.\n */\nexport function getStateBeforeOptimisticTransaction( state, transactionId ) {\n\tconst transaction = find( state.optimist, ( entry ) => (\n\t\tentry.beforeState &&\n\t\tget( entry.action, [ 'optimist', 'id' ] ) === transactionId\n\t) );\n\n\treturn transaction ? transaction.beforeState : null;\n}\n\n/**\n * Returns true if the post is being published, or false otherwise.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether post is being published.\n */\nexport function isPublishingPost( state ) {\n\tif ( ! isSavingPost( state ) ) {\n\t\treturn false;\n\t}\n\n\t// Saving is optimistic, so assume that current post would be marked as\n\t// published if publishing\n\tif ( ! isCurrentPostPublished( state ) ) {\n\t\treturn false;\n\t}\n\n\t// Use post update transaction ID to retrieve the state prior to the\n\t// optimistic transaction\n\tconst stateBeforeRequest = getStateBeforeOptimisticTransaction(\n\t\tstate,\n\t\tPOST_UPDATE_TRANSACTION_ID\n\t);\n\n\t// Consider as publishing when current post prior to request was not\n\t// considered published\n\treturn !! stateBeforeRequest && ! isCurrentPostPublished( stateBeforeRequest );\n}\n\n/**\n * Returns whether the permalink is editable or not.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether or not the permalink is editable.\n */\nexport function isPermalinkEditable( state ) {\n\tconst permalinkTemplate = getEditedPostAttribute( state, 'permalink_template' );\n\n\treturn PERMALINK_POSTNAME_REGEX.test( permalinkTemplate );\n}\n\n/**\n * Returns the permalink for the post.\n *\n * @param {Object} state Editor state.\n *\n * @return {string} The permalink.\n */\nexport function getPermalink( state ) {\n\tconst { prefix, postName, suffix } = getPermalinkParts( state );\n\n\tif ( isPermalinkEditable( state ) ) {\n\t\treturn prefix + postName + suffix;\n\t}\n\n\treturn prefix;\n}\n\n/**\n * Returns the permalink for a post, split into it's three parts: the prefix, the postName, and the suffix.\n *\n * @param {Object} state Editor state.\n *\n * @return {Object} The prefix, postName, and suffix for the permalink.\n */\nexport function getPermalinkParts( state ) {\n\tconst permalinkTemplate = getEditedPostAttribute( state, 'permalink_template' );\n\tconst postName = getEditedPostAttribute( state, 'slug' ) || getEditedPostAttribute( state, 'generated_slug' );\n\n\tconst [ prefix, suffix ] = permalinkTemplate.split( PERMALINK_POSTNAME_REGEX );\n\n\treturn {\n\t\tprefix,\n\t\tpostName,\n\t\tsuffix,\n\t};\n}\n\n/**\n * Returns true if an optimistic transaction is pending commit, for which the\n * before state satisfies the given predicate function.\n *\n * @param {Object}   state     Editor state.\n * @param {Function} predicate Function given state, returning true if match.\n *\n * @return {boolean} Whether predicate matches for some history.\n */\nexport function inSomeHistory( state, predicate ) {\n\tconst { optimist } = state;\n\n\t// In recursion, optimist state won't exist. Assume exhausted options.\n\tif ( ! optimist ) {\n\t\treturn false;\n\t}\n\n\treturn optimist.some( ( { beforeState } ) => (\n\t\tbeforeState && predicate( beforeState )\n\t) );\n}\n\n/**\n * Returns the Block List settings of a block, if any exist.\n *\n * @param {Object}  state    Editor state.\n * @param {?string} clientId Block client ID.\n *\n * @return {?Object} Block settings of the block if set.\n */\nexport function getBlockListSettings( state, clientId ) {\n\treturn state.blockListSettings[ clientId ];\n}\n\n/**\n * Returns the editor settings.\n *\n * @param {Object} state Editor state.\n *\n * @return {Object} The editor settings object.\n */\nexport function getEditorSettings( state ) {\n\treturn state.settings;\n}\n\n/**\n * Returns the token settings.\n *\n * @param {Object} state Editor state.\n * @param {?string} name Token name.\n *\n * @return {Object} Token settings object, or the named token settings object if set.\n */\nexport function getTokenSettings( state, name ) {\n\tif ( ! name ) {\n\t\treturn state.tokens;\n\t}\n\n\treturn state.tokens[ name ];\n}\n\n/**\n * Returns whether the post is locked.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Is locked.\n */\nexport function isPostLocked( state ) {\n\treturn state.postLock.isLocked;\n}\n\n/**\n * Returns whether post saving is locked.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Is locked.\n */\nexport function isPostSavingLocked( state ) {\n\treturn state.postSavingLock.length > 0;\n}\n\n/**\n * Returns whether the edition of the post has been taken over.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Is post lock takeover.\n */\nexport function isPostLockTakeover( state ) {\n\treturn state.postLock.isTakeover;\n}\n\n/**\n * Returns details about the post lock user.\n *\n * @param {Object} state Global application state.\n *\n * @return {Object} A user object.\n */\nexport function getPostLockUser( state ) {\n\treturn state.postLock.user;\n}\n\n/**\n * Returns the active post lock.\n *\n * @param {Object} state Global application state.\n *\n * @return {Object} The lock object.\n */\nexport function getActivePostLock( state ) {\n\treturn state.postLock.activePostLock;\n}\n\n/**\n * Returns whether or not the user has the unfiltered_html capability.\n *\n * @param {Object} state Editor state.\n *\n * @return {boolean} Whether the user can or can't post unfiltered HTML.\n */\nexport function canUserUseUnfilteredHTML( state ) {\n\treturn has( getCurrentPost( state ), [ '_links', 'wp:action-unfiltered-html' ] );\n}\n\n/**\n * Returns whether the pre-publish panel should be shown\n * or skipped when the user clicks the \"publish\" button.\n *\n * @param {Object} state Global application state.\n *\n * @return {boolean} Whether the pre-publish panel should be shown or not.\n */\nexport function isPublishSidebarEnabled( state ) {\n\tif ( state.preferences.hasOwnProperty( 'isPublishSidebarEnabled' ) ) {\n\t\treturn state.preferences.isPublishSidebarEnabled;\n\t}\n\treturn PREFERENCES_DEFAULTS.isPublishSidebarEnabled;\n}\n\n//\n// Deprecated\n//\n\nexport function getNotices() {\n\tdeprecated( 'getNotices selector (`core/editor` store)', {\n\t\talternative: 'getNotices selector (`core/notices` store)',\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t} );\n\n\treturn select( 'core/notices' ).getNotices();\n}\n\nexport function getReusableBlock( state, ref ) {\n\tdeprecated( \"wp.data.select( 'core/editor' ).getReusableBlock( ref )\", {\n\t\talternative: \"wp.data.select( 'core' ).getEntityRecord( 'postType', 'wp_block', ref )\",\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t} );\n\n\treturn __experimentalGetReusableBlock( state, ref );\n}\n\nexport function isSavingReusableBlock( state, ref ) {\n\tdeprecated( 'isSavingReusableBlock selector (`core/editor` store)', {\n\t\talternative: '__experimentalIsSavingReusableBlock selector (`core/edtior` store)',\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t\thint: 'Using experimental APIs is strongly discouraged as they are subject to removal without notice.',\n\t} );\n\n\treturn __experimentalIsSavingReusableBlock( state, ref );\n}\n\nexport function isFetchingReusableBlock( state, ref ) {\n\tdeprecated( \"wp.data.select( 'core/editor' ).isFetchingReusableBlock( ref )\", {\n\t\talternative: \"wp.data.select( 'core' ).isResolving( 'getEntityRecord', 'wp_block', ref )\",\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t} );\n\n\treturn __experimentalIsFetchingReusableBlock( state, ref );\n}\n\nexport function getReusableBlocks( state ) {\n\tdeprecated( \"wp.data.select( 'core/editor' ).getReusableBlocks( ref )\", {\n\t\talternative: \"wp.data.select( 'core' ).getEntityRecords( 'postType', 'wp_block' )\",\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4.0',\n\t} );\n\n\treturn __experimentalGetReusableBlocks( state );\n}\n"]}