{"version":3,"sources":["/Users/ky/Sites/valet/copesacontent/web/app/plugins/gutenberg/packages/core-data/src/selectors.js"],"names":["isResolving","selectorName","args","REDUCER_KEY","isRequestingEmbedPreview","state","url","getAuthors","getUserQueryResults","queryID","queryResults","users","queries","id","byId","getEntitiesByKind","kind","entities","config","getEntity","name","getEntityRecord","key","data","getEntityRecords","query","queriedState","getThemeSupports","themeSupports","getEmbedPreview","embedPreviews","isPreviewEmbedFallback","preview","oEmbedLinkCheck","html"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport createSelector from 'rememo';\nimport { map, find, get, filter } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { REDUCER_KEY } from './name';\nimport { getQueriedItems } from './queried-data';\n\n/**\n * Returns true if resolution is in progress for the core selector of the given\n * name and arguments.\n *\n * @param {string} selectorName Core data selector name.\n * @param {...*}   args         Arguments passed to selector.\n *\n * @return {boolean} Whether resolution is in progress.\n */\nfunction isResolving( selectorName, ...args ) {\n\treturn select( 'core/data' ).isResolving( REDUCER_KEY, selectorName, args );\n}\n\n/**\n * Returns true if a request is in progress for embed preview data, or false\n * otherwise.\n *\n * @param {Object} state Data state.\n * @param {string} url   URL the preview would be for.\n *\n * @return {boolean} Whether a request is in progress for an embed preview.\n */\nexport function isRequestingEmbedPreview( state, url ) {\n\treturn isResolving( 'getEmbedPreview', url );\n}\n\n/**\n * Returns all available authors.\n *\n * @param {Object} state Data state.\n *\n * @return {Array} Authors list.\n */\nexport function getAuthors( state ) {\n\treturn getUserQueryResults( state, 'authors' );\n}\n\n/**\n * Returns all the users returned by a query ID.\n *\n * @param {Object} state   Data state.\n * @param {string} queryID Query ID.\n *\n * @return {Array} Users list.\n */\nexport const getUserQueryResults = createSelector(\n\t( state, queryID ) => {\n\t\tconst queryResults = state.users.queries[ queryID ];\n\n\t\treturn map( queryResults, ( id ) => state.users.byId[ id ] );\n\t},\n\t( state, queryID ) => [ state.users.queries[ queryID ], state.users.byId ]\n);\n\n/**\n * Returns whether the entities for the give kind are loaded.\n *\n * @param {Object} state   Data state.\n * @param {string} kind  Entity kind.\n *\n * @return {boolean} Whether the entities are loaded\n */\nexport function getEntitiesByKind( state, kind ) {\n\treturn filter( state.entities.config, { kind } );\n}\n\n/**\n * Returns the entity object given its kind and name.\n *\n * @param {Object} state   Data state.\n * @param {string} kind  Entity kind.\n * @param {string} name  Entity name.\n *\n * @return {Object} Entity\n */\nexport function getEntity( state, kind, name ) {\n\treturn find( state.entities.config, { kind, name } );\n}\n\n/**\n * Returns the Entity's record object by key.\n *\n * @param {Object} state  State tree\n * @param {string} kind   Entity kind.\n * @param {string} name   Entity name.\n * @param {number} key    Record's key\n *\n * @return {Object?} Record.\n */\nexport function getEntityRecord( state, kind, name, key ) {\n\treturn get( state.entities.data, [ kind, name, 'items', key ] );\n}\n\n/**\n * Returns the Entity's records.\n *\n * @param {Object}  state  State tree\n * @param {string}  kind   Entity kind.\n * @param {string}  name   Entity name.\n * @param {?Object} query  Optional terms query.\n *\n * @return {Array} Records.\n */\nexport function getEntityRecords( state, kind, name, query ) {\n\tconst queriedState = get( state.entities.data, [ kind, name ] );\n\tif ( ! queriedState ) {\n\t\treturn [];\n\t}\n\treturn getQueriedItems( queriedState, query );\n}\n\n/**\n * Return theme supports data in the index.\n *\n * @param {Object} state Data state.\n *\n * @return {*}           Index data.\n */\nexport function getThemeSupports( state ) {\n\treturn state.themeSupports;\n}\n\n/**\n * Returns the embed preview for the given URL.\n *\n * @param {Object} state    Data state.\n * @param {string} url      Embedded URL.\n *\n * @return {*} Undefined if the preview has not been fetched, otherwise, the preview fetched from the embed preview API.\n */\nexport function getEmbedPreview( state, url ) {\n\treturn state.embedPreviews[ url ];\n}\n\n/**\n * Determines if the returned preview is an oEmbed link fallback.\n *\n * WordPress can be configured to return a simple link to a URL if it is not embeddable.\n * We need to be able to determine if a URL is embeddable or not, based on what we\n * get back from the oEmbed preview API.\n *\n * @param {Object} state    Data state.\n * @param {string} url      Embedded URL.\n *\n * @return {booleans} Is the preview for the URL an oEmbed link fallback.\n */\nexport function isPreviewEmbedFallback( state, url ) {\n\tconst preview = state.embedPreviews[ url ];\n\tconst oEmbedLinkCheck = '<a href=\"' + url + '\">' + url + '</a>';\n\tif ( ! preview ) {\n\t\treturn false;\n\t}\n\treturn preview.html === oEmbedLinkCheck;\n}\n"]}