{"version":3,"sources":["/Users/ky/Sites/valet/copesacontent/web/app/plugins/gutenberg/packages/data/src/components/with-select/index.js"],"names":["Component","isShallowEqual","createHigherOrderComponent","RegistryConsumer","withSelect","mapSelectToProps","WrappedComponent","DEFAULT_MERGE_PROPS","getNextMergeProps","props","registry","select","ownProps","ComponentWithSelect","subscribe","mergeProps","canRunSelection","unsubscribe","nextProps","nextState","hasRegistryChanged","hasPropsChanged","state","nextMergeProps","setState"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { Component } from '@wordpress/element';\nimport isShallowEqual from '@wordpress/is-shallow-equal';\nimport { createHigherOrderComponent } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { RegistryConsumer } from '../registry-provider';\n\n/**\n * Higher-order component used to inject state-derived props using registered\n * selectors.\n *\n * @param {Function} mapSelectToProps Function called on every state change,\n *                                   expected to return object of props to\n *                                   merge with the component's own props.\n *\n * @return {Component} Enhanced component with merged state data props.\n */\nconst withSelect = ( mapSelectToProps ) => createHigherOrderComponent( ( WrappedComponent ) => {\n\t/**\n\t * Default merge props. A constant value is used as the fallback since it\n\t * can be more efficiently shallow compared in case component is repeatedly\n \t * rendered without its own merge props.\n\t *\n\t * @type {Object}\n\t */\n\tconst DEFAULT_MERGE_PROPS = {};\n\n\t/**\n\t * Given a props object, returns the next merge props by mapSelectToProps.\n\t *\n\t * @param {Object} props Props to pass as argument to mapSelectToProps.\n\t *\n\t * @return {Object} Props to merge into rendered wrapped element.\n\t */\n\tfunction getNextMergeProps( props ) {\n\t\treturn (\n\t\t\tmapSelectToProps( props.registry.select, props.ownProps ) ||\n\t\t\tDEFAULT_MERGE_PROPS\n\t\t);\n\t}\n\n\tclass ComponentWithSelect extends Component {\n\t\tconstructor( props ) {\n\t\t\tsuper( props );\n\n\t\t\tthis.subscribe( props.registry );\n\n\t\t\tthis.mergeProps = getNextMergeProps( props );\n\t\t}\n\n\t\tcomponentDidMount() {\n\t\t\tthis.canRunSelection = true;\n\t\t}\n\n\t\tcomponentWillUnmount() {\n\t\t\tthis.canRunSelection = false;\n\t\t\tthis.unsubscribe();\n\t\t}\n\n\t\tshouldComponentUpdate( nextProps, nextState ) {\n\t\t\t// Cycle subscription if registry changes.\n\t\t\tconst hasRegistryChanged = nextProps.registry !== this.props.registry;\n\t\t\tif ( hasRegistryChanged ) {\n\t\t\t\tthis.unsubscribe();\n\t\t\t\tthis.subscribe( nextProps.registry );\n\t\t\t}\n\n\t\t\t// Treat a registry change as equivalent to `ownProps`, to reflect\n\t\t\t// `mergeProps` to rendered component if and only if updated.\n\t\t\tconst hasPropsChanged = (\n\t\t\t\thasRegistryChanged ||\n\t\t\t\t! isShallowEqual( this.props.ownProps, nextProps.ownProps )\n\t\t\t);\n\n\t\t\t// Only render if props have changed or merge props have been updated\n\t\t\t// from the store subscriber.\n\t\t\tif ( this.state === nextState && ! hasPropsChanged ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ( hasPropsChanged ) {\n\t\t\t\tconst nextMergeProps = getNextMergeProps( nextProps );\n\t\t\t\tif ( ! isShallowEqual( this.mergeProps, nextMergeProps ) ) {\n\t\t\t\t\t// If merge props change as a result of the incoming props,\n\t\t\t\t\t// they should be reflected as such in the upcoming render.\n\t\t\t\t\t// While side effects are discouraged in lifecycle methods,\n\t\t\t\t\t// this component is used heavily, and prior efforts to use\n\t\t\t\t\t// `getDerivedStateFromProps` had demonstrated miserable\n\t\t\t\t\t// performance.\n\t\t\t\t\tthis.mergeProps = nextMergeProps;\n\t\t\t\t}\n\n\t\t\t\t// Regardless whether merge props are changing, fall through to\n\t\t\t\t// incur the render since the component will need to receive\n\t\t\t\t// the changed `ownProps`.\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tsubscribe( registry ) {\n\t\t\tthis.unsubscribe = registry.subscribe( () => {\n\t\t\t\tif ( ! this.canRunSelection ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst nextMergeProps = getNextMergeProps( this.props );\n\t\t\t\tif ( isShallowEqual( this.mergeProps, nextMergeProps ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.mergeProps = nextMergeProps;\n\n\t\t\t\t// Schedule an update. Merge props are not assigned to state\n\t\t\t\t// because derivation of merge props from incoming props occurs\n\t\t\t\t// within shouldComponentUpdate, where setState is not allowed.\n\t\t\t\t// setState is used here instead of forceUpdate because forceUpdate\n\t\t\t\t// bypasses shouldComponentUpdate altogether, which isn't desireable\n\t\t\t\t// if both state and props change within the same render.\n\t\t\t\t// Unfortunately this requires that next merge props are generated\n\t\t\t\t// twice.\n\t\t\t\tthis.setState( {} );\n\t\t\t} );\n\t\t}\n\n\t\trender() {\n\t\t\treturn <WrappedComponent { ...this.props.ownProps } { ...this.mergeProps } />;\n\t\t}\n\t}\n\n\treturn ( ownProps ) => (\n\t\t<RegistryConsumer>\n\t\t\t{ ( registry ) => (\n\t\t\t\t<ComponentWithSelect\n\t\t\t\t\townProps={ ownProps }\n\t\t\t\t\tregistry={ registry }\n\t\t\t\t/>\n\t\t\t) }\n\t\t</RegistryConsumer>\n\t);\n}, 'withSelect' );\n\nexport default withSelect;\n"]}