{"version":3,"sources":["/Users/ky/Sites/valet/copesacontent/web/app/plugins/gutenberg/packages/blocks/src/api/validation.js"],"names":["tokenize","xor","fromPairs","isEqual","includes","stubTrue","deprecated","getSaveContent","REGEXP_WHITESPACE","REGEXP_ONLY_WHITESPACE","REGEXP_STYLE_URL_TYPE","BOOLEAN_ATTRIBUTES","ENUMERATED_ATTRIBUTES","MEANINGFUL_ATTRIBUTES","log","createLogger","logger","process","env","NODE_ENV","require","sprintf","message","args","error","console","warning","warn","getTextPiecesSplitOnWhitespace","text","trim","split","getTextWithCollapsedWhitespace","join","getMeaningfulAttributePairs","token","attributes","filter","pair","key","value","indexOf","isEqualTextTokensWithCollapsedWhitespace","actual","expected","isEquivalentText","chars","map","getNormalizedStyleValue","replace","getStyleProperties","pairs","style","valueParts","isEqualAttributesOfName","class","length","attribute","isEqualTagAttributePairs","actualAttributes","expectedAttributes","name","hasOwnProperty","actualValue","expectedValue","isEqualAttributes","isEqualTokensOfType","StartTag","tagName","Chars","Comment","getNextNonWhitespaceToken","tokens","shift","type","test","getHTMLTokens","html","e","isClosedByToken","currentToken","nextToken","selfClosing","isEquivalentHTML","actualTokens","expectedTokens","actualToken","expectedToken","isEqualTokens","isValidBlock","innerHTML","blockType","plugin","version","alternative","hint","isValidBlockContent","saveContent","toString","isValid"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { tokenize } from 'simple-html-tokenizer';\nimport { xor, fromPairs, isEqual, includes, stubTrue } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport deprecated from '@wordpress/deprecated';\n\n/**\n * Internal dependencies\n */\nimport { getSaveContent } from './serializer';\n\n/**\n * Globally matches any consecutive whitespace\n *\n * @type {RegExp}\n */\nconst REGEXP_WHITESPACE = /[\\t\\n\\r\\v\\f ]+/g;\n\n/**\n * Matches a string containing only whitespace\n *\n * @type {RegExp}\n */\nconst REGEXP_ONLY_WHITESPACE = /^[\\t\\n\\r\\v\\f ]*$/;\n\n/**\n * Matches a CSS URL type value\n *\n * @type {RegExp}\n */\nconst REGEXP_STYLE_URL_TYPE = /^url\\s*\\(['\"\\s]*(.*?)['\"\\s]*\\)$/;\n\n/**\n * Boolean attributes are attributes whose presence as being assigned is\n * meaningful, even if only empty.\n *\n * See: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes\n * Extracted from: https://html.spec.whatwg.org/multipage/indices.html#attributes-3\n *\n * Object.keys( [ ...document.querySelectorAll( '#attributes-1 > tbody > tr' ) ]\n *     .filter( ( tr ) => tr.lastChild.textContent.indexOf( 'Boolean attribute' ) !== -1 )\n *     .reduce( ( result, tr ) => Object.assign( result, {\n *         [ tr.firstChild.textContent.trim() ]: true\n *     } ), {} ) ).sort();\n *\n * @type {Array}\n */\nconst BOOLEAN_ATTRIBUTES = [\n\t'allowfullscreen',\n\t'allowpaymentrequest',\n\t'allowusermedia',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'defer',\n\t'disabled',\n\t'download',\n\t'formnovalidate',\n\t'hidden',\n\t'ismap',\n\t'itemscope',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'selected',\n\t'typemustmatch',\n];\n\n/**\n * Enumerated attributes are attributes which must be of a specific value form.\n * Like boolean attributes, these are meaningful if specified, even if not of a\n * valid enumerated value.\n *\n * See: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#enumerated-attribute\n * Extracted from: https://html.spec.whatwg.org/multipage/indices.html#attributes-3\n *\n * Object.keys( [ ...document.querySelectorAll( '#attributes-1 > tbody > tr' ) ]\n *     .filter( ( tr ) => /^(\"(.+?)\";?\\s*)+/.test( tr.lastChild.textContent.trim() ) )\n *     .reduce( ( result, tr ) => Object.assign( result, {\n *         [ tr.firstChild.textContent.trim() ]: true\n *     } ), {} ) ).sort();\n *\n * @type {Array}\n */\nconst ENUMERATED_ATTRIBUTES = [\n\t'autocapitalize',\n\t'autocomplete',\n\t'charset',\n\t'contenteditable',\n\t'crossorigin',\n\t'decoding',\n\t'dir',\n\t'draggable',\n\t'enctype',\n\t'formenctype',\n\t'formmethod',\n\t'http-equiv',\n\t'inputmode',\n\t'kind',\n\t'method',\n\t'preload',\n\t'scope',\n\t'shape',\n\t'spellcheck',\n\t'translate',\n\t'type',\n\t'wrap',\n];\n\n/**\n * Meaningful attributes are those who cannot be safely ignored when omitted in\n * one HTML markup string and not another.\n *\n * @type {Array}\n */\nconst MEANINGFUL_ATTRIBUTES = [\n\t...BOOLEAN_ATTRIBUTES,\n\t...ENUMERATED_ATTRIBUTES,\n];\n\n/**\n * Object of logger functions.\n */\nconst log = ( () => {\n\t/**\n\t * Creates a logger with block validation prefix.\n\t *\n\t * @param {Function} logger Original logger function.\n\t *\n\t * @return {Function} Augmented logger function.\n\t */\n\tfunction createLogger( logger ) {\n\t\t// In test environments, pre-process the sprintf message to improve\n\t\t// readability of error messages. We'd prefer to avoid pulling in this\n\t\t// dependency in runtime environments, and it can be dropped by a combo\n\t\t// of Webpack env substitution + UglifyJS dead code elimination.\n\t\tif ( process.env.NODE_ENV === 'test' ) {\n\t\t\treturn ( ...args ) => logger( require( 'sprintf-js' ).sprintf( ...args ) );\n\t\t}\n\n\t\treturn ( message, ...args ) => logger( 'Block validation: ' + message, ...args );\n\t}\n\n\treturn {\n\t\t/* eslint-disable no-console */\n\t\terror: createLogger( console.error ),\n\t\twarning: createLogger( console.warn ),\n\t\t/* eslint-enable no-console */\n\t};\n} )();\n\n/**\n * Given a specified string, returns an array of strings split by consecutive\n * whitespace, ignoring leading or trailing whitespace.\n *\n * @param {string} text Original text.\n *\n * @return {string[]} Text pieces split on whitespace.\n */\nexport function getTextPiecesSplitOnWhitespace( text ) {\n\treturn text.trim().split( REGEXP_WHITESPACE );\n}\n\n/**\n * Given a specified string, returns a new trimmed string where all consecutive\n * whitespace is collapsed to a single space.\n *\n * @param {string} text Original text.\n *\n * @return {string} Trimmed text with consecutive whitespace collapsed.\n */\nexport function getTextWithCollapsedWhitespace( text ) {\n\treturn getTextPiecesSplitOnWhitespace( text ).join( ' ' );\n}\n\n/**\n * Returns attribute pairs of the given StartTag token, including only pairs\n * where the value is non-empty or the attribute is a boolean attribute, an\n * enumerated attribute, or a custom data- attribute.\n *\n * @see MEANINGFUL_ATTRIBUTES\n *\n * @param {Object} token StartTag token.\n *\n * @return {Array[]} Attribute pairs.\n */\nexport function getMeaningfulAttributePairs( token ) {\n\treturn token.attributes.filter( ( pair ) => {\n\t\tconst [ key, value ] = pair;\n\t\treturn (\n\t\t\tvalue ||\n\t\t\tkey.indexOf( 'data-' ) === 0 ||\n\t\t\tincludes( MEANINGFUL_ATTRIBUTES, key )\n\t\t);\n\t} );\n}\n\n/**\n * Returns true if two text tokens (with `chars` property) are equivalent, or\n * false otherwise.\n *\n * @param {Object} actual   Actual token.\n * @param {Object} expected Expected token.\n *\n * @return {boolean} Whether two text tokens are equivalent.\n */\nexport function isEqualTextTokensWithCollapsedWhitespace( actual, expected ) {\n\t// This is an overly simplified whitespace comparison. The specification is\n\t// more prescriptive of whitespace behavior in inline and block contexts.\n\t//\n\t// See: https://medium.com/@patrickbrosset/when-does-white-space-matter-in-html-b90e8a7cdd33\n\tconst isEquivalentText = isEqual( ...[ actual.chars, expected.chars ].map( getTextWithCollapsedWhitespace ) );\n\n\tif ( ! isEquivalentText ) {\n\t\tlog.warning( 'Expected text `%s`, saw `%s`.', expected.chars, actual.chars );\n\t}\n\n\treturn isEquivalentText;\n}\n\n/**\n * Given a style value, returns a normalized style value for strict equality\n * comparison.\n *\n * @param {string} value Style value.\n *\n * @return {string} Normalized style value.\n */\nexport function getNormalizedStyleValue( value ) {\n\treturn value\n\t\t// Normalize URL type to omit whitespace or quotes\n\t\t.replace( REGEXP_STYLE_URL_TYPE, 'url($1)' );\n}\n\n/**\n * Given a style attribute string, returns an object of style properties.\n *\n * @param {string} text Style attribute.\n *\n * @return {Object} Style properties.\n */\nexport function getStyleProperties( text ) {\n\tconst pairs = text\n\t\t// Trim ending semicolon (avoid including in split)\n\t\t.replace( /;?\\s*$/, '' )\n\t\t// Split on property assignment\n\t\t.split( ';' )\n\t\t// For each property assignment...\n\t\t.map( ( style ) => {\n\t\t\t// ...split further into key-value pairs\n\t\t\tconst [ key, ...valueParts ] = style.split( ':' );\n\t\t\tconst value = valueParts.join( ':' );\n\n\t\t\treturn [\n\t\t\t\tkey.trim(),\n\t\t\t\tgetNormalizedStyleValue( value.trim() ),\n\t\t\t];\n\t\t} );\n\n\treturn fromPairs( pairs );\n}\n\n/**\n * Attribute-specific equality handlers\n *\n * @type {Object}\n */\nexport const isEqualAttributesOfName = {\n\tclass: ( actual, expected ) => {\n\t\t// Class matches if members are the same, even if out of order or\n\t\t// superfluous whitespace between.\n\t\treturn ! xor( ...[ actual, expected ].map( getTextPiecesSplitOnWhitespace ) ).length;\n\t},\n\tstyle: ( actual, expected ) => {\n\t\treturn isEqual( ...[ actual, expected ].map( getStyleProperties ) );\n\t},\n\t// For each boolean attribute, mere presence of attribute in both is enough\n\t// to assume equivalence.\n\t...fromPairs( BOOLEAN_ATTRIBUTES.map( ( attribute ) => [ attribute, stubTrue ] ) ),\n};\n\n/**\n * Given two sets of attribute tuples, returns true if the attribute sets are\n * equivalent.\n *\n * @param {Array[]} actual   Actual attributes tuples.\n * @param {Array[]} expected Expected attributes tuples.\n *\n * @return {boolean} Whether attributes are equivalent.\n */\nexport function isEqualTagAttributePairs( actual, expected ) {\n\t// Attributes is tokenized as tuples. Their lengths should match. This also\n\t// avoids us needing to check both attributes sets, since if A has any keys\n\t// which do not exist in B, we know the sets to be different.\n\tif ( actual.length !== expected.length ) {\n\t\tlog.warning( 'Expected attributes %o, instead saw %o.', expected, actual );\n\t\treturn false;\n\t}\n\n\t// Convert tuples to object for ease of lookup\n\tconst [ actualAttributes, expectedAttributes ] = [ actual, expected ].map( fromPairs );\n\n\tfor ( const name in actualAttributes ) {\n\t\t// As noted above, if missing member in B, assume different\n\t\tif ( ! expectedAttributes.hasOwnProperty( name ) ) {\n\t\t\tlog.warning( 'Encountered unexpected attribute `%s`.', name );\n\t\t\treturn false;\n\t\t}\n\n\t\tconst actualValue = actualAttributes[ name ];\n\t\tconst expectedValue = expectedAttributes[ name ];\n\n\t\tconst isEqualAttributes = isEqualAttributesOfName[ name ];\n\t\tif ( isEqualAttributes ) {\n\t\t\t// Defer custom attribute equality handling\n\t\t\tif ( ! isEqualAttributes( actualValue, expectedValue ) ) {\n\t\t\t\tlog.warning( 'Expected attribute `%s` of value `%s`, saw `%s`.', name, expectedValue, actualValue );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if ( actualValue !== expectedValue ) {\n\t\t\t// Otherwise strict inequality should bail\n\t\t\tlog.warning( 'Expected attribute `%s` of value `%s`, saw `%s`.', name, expectedValue, actualValue );\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Token-type-specific equality handlers\n *\n * @type {Object}\n */\nexport const isEqualTokensOfType = {\n\tStartTag: ( actual, expected ) => {\n\t\tif ( actual.tagName !== expected.tagName ) {\n\t\t\tlog.warning( 'Expected tag name `%s`, instead saw `%s`.', expected.tagName, actual.tagName );\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isEqualTagAttributePairs(\n\t\t\t...[ actual, expected ].map( getMeaningfulAttributePairs )\n\t\t);\n\t},\n\tChars: isEqualTextTokensWithCollapsedWhitespace,\n\tComment: isEqualTextTokensWithCollapsedWhitespace,\n};\n\n/**\n * Given an array of tokens, returns the first token which is not purely\n * whitespace.\n *\n * Mutates the tokens array.\n *\n * @param {Object[]} tokens Set of tokens to search.\n *\n * @return {Object} Next non-whitespace token.\n */\nexport function getNextNonWhitespaceToken( tokens ) {\n\tlet token;\n\twhile ( ( token = tokens.shift() ) ) {\n\t\tif ( token.type !== 'Chars' ) {\n\t\t\treturn token;\n\t\t}\n\n\t\tif ( ! REGEXP_ONLY_WHITESPACE.test( token.chars ) ) {\n\t\t\treturn token;\n\t\t}\n\t}\n}\n\n/**\n * Tokenize an HTML string, gracefully handling any errors thrown during\n * underlying tokenization.\n *\n * @param {string} html HTML string to tokenize.\n *\n * @return {Object[]|null} Array of valid tokenized HTML elements, or null on error\n */\nfunction getHTMLTokens( html ) {\n\ttry {\n\t\treturn tokenize( html );\n\t} catch ( e ) {\n\t\tlog.warning( 'Malformed HTML detected: %s', html );\n\t}\n\n\treturn null;\n}\n\n/**\n * Returns true if the next HTML token closes the current token.\n *\n * @param {Object} currentToken Current token to compare with.\n * @param {Object|undefined} nextToken Next token to compare against.\n *\n * @return {boolean} true if `nextToken` closes `currentToken`, false otherwise\n */\nexport function isClosedByToken( currentToken, nextToken ) {\n\t// Ensure this is a self closed token\n\tif ( ! currentToken.selfClosing ) {\n\t\treturn false;\n\t}\n\n\t// Check token names and determine if nextToken is the closing tag for currentToken\n\tif ( nextToken && nextToken.tagName === currentToken.tagName && nextToken.type === 'EndTag' ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Returns true if the given HTML strings are effectively equivalent, or\n * false otherwise. Invalid HTML is not considered equivalent, even if the\n * strings directly match.\n *\n * @param {string} actual Actual HTML string.\n * @param {string} expected Expected HTML string.\n *\n * @return {boolean} Whether HTML strings are equivalent.\n */\nexport function isEquivalentHTML( actual, expected ) {\n\t// Tokenize input content and reserialized save content\n\tconst [ actualTokens, expectedTokens ] = [ actual, expected ].map( getHTMLTokens );\n\n\t// If either is malformed then stop comparing - the strings are not equivalent\n\tif ( ! actualTokens || ! expectedTokens ) {\n\t\treturn false;\n\t}\n\n\tlet actualToken, expectedToken;\n\twhile ( ( actualToken = getNextNonWhitespaceToken( actualTokens ) ) ) {\n\t\texpectedToken = getNextNonWhitespaceToken( expectedTokens );\n\n\t\t// Inequal if exhausted all expected tokens\n\t\tif ( ! expectedToken ) {\n\t\t\tlog.warning( 'Expected end of content, instead saw %o.', actualToken );\n\t\t\treturn false;\n\t\t}\n\n\t\t// Inequal if next non-whitespace token of each set are not same type\n\t\tif ( actualToken.type !== expectedToken.type ) {\n\t\t\tlog.warning( 'Expected token of type `%s` (%o), instead saw `%s` (%o).', expectedToken.type, expectedToken, actualToken.type, actualToken );\n\t\t\treturn false;\n\t\t}\n\n\t\t// Defer custom token type equality handling, otherwise continue and\n\t\t// assume as equal\n\t\tconst isEqualTokens = isEqualTokensOfType[ actualToken.type ];\n\t\tif ( isEqualTokens && ! isEqualTokens( actualToken, expectedToken ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Peek at the next tokens (actual and expected) to see if they close\n\t\t// a self-closing tag\n\t\tif ( isClosedByToken( actualToken, expectedTokens[ 0 ] ) ) {\n\t\t\t// Consume the next expected token that closes the current actual\n\t\t\t// self-closing token\n\t\t\tgetNextNonWhitespaceToken( expectedTokens );\n\t\t} else if ( isClosedByToken( expectedToken, actualTokens[ 0 ] ) ) {\n\t\t\t// Consume the next actual token that closes the current expected\n\t\t\t// self-closing token\n\t\t\tgetNextNonWhitespaceToken( actualTokens );\n\t\t}\n\t}\n\n\tif ( ( expectedToken = getNextNonWhitespaceToken( expectedTokens ) ) ) {\n\t\t// If any non-whitespace tokens remain in expected token set, this\n\t\t// indicates inequality\n\t\tlog.warning( 'Expected %o, instead saw end of content.', expectedToken );\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport function isValidBlock( innerHTML, blockType, attributes ) {\n\tdeprecated( 'isValidBlock', {\n\t\tplugin: 'Gutenberg',\n\t\tversion: '4.4',\n\t\talternative: 'isValidBlockContent',\n\t\thint: 'The order of params has changed.',\n\t} );\n\n\treturn isValidBlockContent( blockType, attributes, innerHTML );\n}\n\n/**\n * Returns true if the parsed block is valid given the input content. A block\n * is considered valid if, when serialized with assumed attributes, the content\n * matches the original value.\n *\n * Logs to console in development environments when invalid.\n *\n * @param {string} blockType  Block type.\n * @param {Object} attributes Parsed block attributes.\n * @param {string} innerHTML  Original block content.\n *\n * @return {boolean} Whether block is valid.\n */\nexport function isValidBlockContent( blockType, attributes, innerHTML ) {\n\tlet saveContent;\n\ttry {\n\t\tsaveContent = getSaveContent( blockType, attributes );\n\t} catch ( error ) {\n\t\tlog.error( 'Block validation failed because an error occurred while generating block content:\\n\\n%s', error.toString() );\n\t\treturn false;\n\t}\n\n\tconst isValid = isEquivalentHTML( innerHTML, saveContent );\n\tif ( ! isValid ) {\n\t\tlog.error(\n\t\t\t'Block validation failed for `%s` (%o).\\n\\nExpected:\\n\\n%s\\n\\nActual:\\n\\n%s',\n\t\t\tblockType.name,\n\t\t\tblockType,\n\t\t\tsaveContent,\n\t\t\tinnerHTML\n\t\t);\n\t}\n\n\treturn isValid;\n}\n"]}