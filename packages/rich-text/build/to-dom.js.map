{"version":3,"sources":["/Users/ky/Sites/valet/copesacontent/web/app/plugins/gutenberg/packages/rich-text/src/to-dom.js"],"names":["window","Node","TEXT_NODE","ELEMENT_NODE","createPathToNode","node","rootNode","path","parentNode","i","previousSibling","getNodeByPath","length","childNodes","shift","offset","createEmpty","document","implementation","createHTMLDocument","body","append","element","child","ownerDocument","createTextNode","type","attributes","createElement","key","setAttribute","appendChild","appendText","text","appendData","getLastChild","lastChild","getParent","isText","nodeType","getText","nodeValue","remove","removeChild","padEmptyLines","createLinePadding","multilineWrapperTags","doc","index","indexOf","nodeName","toLowerCase","insertBefore","toDom","value","multilineTag","startPath","endPath","tree","onStartIndex","pointer","onEndIndex","isEditableTree","selection","apply","current","applyValue","start","undefined","applySelection","future","firstChild","currentChild","futureNodeType","replaceChild","startContainer","startOffset","endContainer","endOffset","windowSelection","getSelection","range","createRange","collapsed","insertData","setStart","setEnd","removeAllRanges","addRange"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE, ELEMENT_NODE } = window.Node;\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\nfunction createEmpty() {\n\tconst { body } = document.implementation.createHTMLDocument( '' );\n\treturn body;\n}\n\nfunction append( element, child ) {\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( { nodeType } ) {\n\treturn nodeType === TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nfunction padEmptyLines( { element, createLinePadding, multilineWrapperTags } ) {\n\tconst length = element.childNodes.length;\n\tconst doc = element.ownerDocument;\n\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst child = element.childNodes[ index ];\n\n\t\tif ( child.nodeType === TEXT_NODE ) {\n\t\t\tif ( length === 1 && ! child.nodeValue ) {\n\t\t\t\t// Pad if the only child is an empty text node.\n\t\t\t\telement.appendChild( createLinePadding( doc ) );\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\tmultilineWrapperTags &&\n\t\t\t\t! child.previousSibling &&\n\t\t\t\tmultilineWrapperTags.indexOf( child.nodeName.toLowerCase() ) !== -1\n\t\t\t) {\n\t\t\t\t// Pad the line if there is no content before a nested wrapper.\n\t\t\t\telement.insertBefore( createLinePadding( doc ), child );\n\t\t\t}\n\n\t\t\tpadEmptyLines( { element: child, createLinePadding, multilineWrapperTags } );\n\t\t}\n\t}\n}\n\nexport function toDom( {\n\tvalue,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcreateLinePadding,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\t\t},\n\t\tisEditableTree: true,\n\t} );\n\n\tif ( createLinePadding ) {\n\t\tpadEmptyLines( { element: tree, createLinePadding, multilineWrapperTags } );\n\t}\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`. If a `multilineTag` is provided,\n * text separated by two new lines will be wrapped in an `Element` of that type.\n *\n * @param {Object}      value        Value to apply.\n * @param {HTMLElement} current      The live root node to apply the element\n *                                   tree to.\n * @param {string}      multilineTag Multiline tag.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcreateLinePadding,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tcreateLinePadding,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\n\twhile ( future.firstChild ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\t\tconst futureNodeType = future.firstChild.nodeType;\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( future.firstChild );\n\t\t} else if (\n\t\t\tfutureNodeType !== currentChild.nodeType ||\n\t\t\tfutureNodeType !== TEXT_NODE ||\n\t\t\tfuture.firstChild.nodeValue !== currentChild.nodeValue\n\t\t) {\n\t\t\tcurrent.replaceChild( future.firstChild, currentChild );\n\t\t} else {\n\t\t\tfuture.removeChild( future.firstChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\nexport function applySelection( selection, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath( current, selection.startPath );\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath( current, selection.endPath );\n\n\tconst windowSelection = window.getSelection();\n\tconst range = current.ownerDocument.createRange();\n\tconst collapsed = startContainer === endContainer && startOffset === endOffset;\n\n\tif (\n\t\tcollapsed &&\n\t\tstartOffset === 0 &&\n\t\tstartContainer.previousSibling &&\n\t\tstartContainer.previousSibling.nodeType === ELEMENT_NODE &&\n\t\tstartContainer.previousSibling.nodeName !== 'BR'\n\t) {\n\t\tstartContainer.insertData( 0, '\\uFEFF' );\n\t\trange.setStart( startContainer, 1 );\n\t\trange.setEnd( endContainer, 1 );\n\t} else if (\n\t\tcollapsed &&\n\t\tstartOffset === 0 &&\n\t\tstartContainer === TEXT_NODE &&\n\t\tstartContainer.nodeValue.length === 0\n\t) {\n\t\tstartContainer.insertData( 0, '\\uFEFF' );\n\t\trange.setStart( startContainer, 1 );\n\t\trange.setEnd( endContainer, 1 );\n\t} else {\n\t\trange.setStart( startContainer, startOffset );\n\t\trange.setEnd( endContainer, endOffset );\n\t}\n\n\twindowSelection.removeAllRanges();\n\twindowSelection.addRange( range );\n}\n"]}